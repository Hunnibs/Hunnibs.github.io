<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-04-26T22:31:09+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hunnibs</title><subtitle>About my work history &amp; review
</subtitle><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><entry><title type="html"></title><link href="http://localhost:4000/jekyll/2023-04-26-2023-04-25-jekyll-setting(2)/" rel="alternate" type="text/html" title="" /><published>2023-04-26T22:31:09+09:00</published><updated>2023-04-26T21:26:13+09:00</updated><id>http://localhost:4000/jekyll/2023-04-25-jekyll-setting(2)</id><content type="html" xml:base="http://localhost:4000/jekyll/2023-04-26-2023-04-25-jekyll-setting(2)/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#toctable-of-content" id="markdown-toc-toctable-of-content">TOC(Table of Content)</a></li>
</ul>

<hr />
<h3 id="toctable-of-content">TOC(Table of Content)</h3>
<hr />
<p>HydeJack Theme에서는 따로 TOC 기능을 제공하고 있지 않아 추가해주어야하는데 방법은 매우 간단하다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    ---
    layout: post
    title:  "[Jekyll] GitHub 블로그 개발일지(3)"
    description: &gt;
    "블로그 관련 꾸며가는 과정"
    
    hide_last_modified: true
    ---
    * TOC
    {:toc}

</code></pre></div></div>

<p>다음과 같이 본문이 시작되기 전 두 문장만 추가로 넣어주면 된다.</p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="jekyll" /></entry><entry><title type="html">메타버스</title><link href="http://localhost:4000/it/2023-04-26-it-metaverse/" rel="alternate" type="text/html" title="메타버스" /><published>2023-04-26T00:00:00+09:00</published><updated>2023-04-26T22:27:29+09:00</updated><id>http://localhost:4000/it/it-metaverse</id><content type="html" xml:base="http://localhost:4000/it/2023-04-26-it-metaverse/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#정의" id="markdown-toc-정의">정의</a></li>
  <li><a href="#메타버스의-4가지-유형" id="markdown-toc-메타버스의-4가지-유형">메타버스의 4가지 유형</a></li>
  <li><a href="#특징" id="markdown-toc-특징">특징</a></li>
  <li><a href="#참조" id="markdown-toc-참조">참조</a></li>
</ul>
<hr />
<h3 id="정의">정의</h3>
<hr />
<p>메타버스(metaverse)는 ‘웹상에서 아바타를 이용하여 사회, 경제, 문화적 활동을 하는 따위처럼 가상 세계와 현실 세계의 경계가 허물어지는 것을 이르는 말’이다.</p>

<h3 id="메타버스의-4가지-유형">메타버스의 4가지 유형</h3>
<hr />
<p>메타버스는 간단하게는 가상세계를 뜻하는 개념이지만 4개로 분류하여 훨씬 더 확장적인 의미로 사용하고 있다.</p>

<p align="center"><img src="/assets/img/it/metaverse.jpg" width="400px" height="400px" title="px(픽셀) 크기 설정" alt="metaverse" /></p>

<ol>
  <li>
    <dl>
      <dt>AR(AUGMENTED REALITY)</dt>
      <dd>증강현실을 뜻하며 현실의 이미지나 배경에 3차원 가상 이미지를 겹쳐서 하나의 영상으로 보여주는 기술 <br />
ex) 포켓몬고, Google SKY Map</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>LIFELOGGING</dt>
      <dd>개인의 일상을 인터넷 또는 스마트 기기에 기록하는 것으로, ‘일상의 디지털화’라고 할 수 있다. <br />
ex) 스마트밴드, SNS</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>MIRROR WORLD</dt>
      <dd>AR과 달리 현실세계를 인터넷에 3차원 CG로 재현하여 시뮬레이션 등을 통한 의사결정 증강지원 시스템이다.  <br />
ex) 구글어스</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>VR(VIRTUAL WORLDS)</dt>
      <dd>흔히 아는 가상현실을 뜻하며 컴퓨터 등을 사용한 인공적인 기술로 만들어낸 실제와 유사하지만 실제가 아닌 어떤 특정한 환경이나 상황 혹은 그 기술 자체를 의미한다. <br />
ex) 제페토, 로블록스</dd>
    </dl>
  </li>
</ol>

<h3 id="특징">특징</h3>
<hr />
<p><strong>- NFT의 활용이 가능하다!</strong></p>
<ul>
  <li>디지털 아트의 소유권을 공식화하는 방법으로 시작</li>
  <li>현재는 디지털 부동산 등 다른 유형의 디지털 자산마저 NFT로 만들어졌다</li>
  <li>더 샌드박스, 제페토, 로블록스 등 대부분의 메타버스 플랫폼에서 이를 도입해 일부 디지털 자산을 NFT로 만들었다</li>
</ul>

<blockquote>
  <p>NFT(non-fungible token)란? <br />
대체 불가능한 토큰을 뜻한다.
블록체인에 저장된 데이터 단위로 흔히 아는 암호화폐와는 다르게 고유하면서 상호 교환할 수 없는 특징을 가진다. <br />
쉽게 말하면 암호화폐마다 고유한 번호가 매겨져있기 때문에 각각이 다른 가치를 가지고 대체가 될 수 없다는 것을 뜻한다.
그래서 NFT는 한 번 발행되면 제 3자가 이를 복제하거나 위조할 수가 없고 소유권과 거래내역이 명시되어 ‘디지털 소유 증명서’처럼 활용이 가능하다.</p>
</blockquote>

<p><img src="/assets/img/it/sandbox.png" alt="sandbox" /></p>

<ul>
  <li>더 샌드박스 NFT를 예시로 들었을 때 모든 토큰은 각자 고유의 가치와 활용성을 지니고 상호작용 할 수 있도록 디자인되었다.</li>
  <li>이는 독창성을 입증할 수 있기 때문에 가치나 유일성을 입증할 수 있는 좋은 방법으로 보인다.
<br /></li>
</ul>

<p><strong>- 가상세계에서의 경제활동이 가능하다!</strong></p>
<ul>
  <li>메타버스는 NFT를 활용하는 것 이외에도 경제활동이 가능하다.</li>
  <li>NFT가 자신의 디지털 자산이라면 그것을 사고 팔기 위한 경제활동이 가능하다는 뜻</li>
  <li>경제활동을 하는 가장 흥미있는 메타버스는 ‘어스2’
    <ul>
      <li>어스2는 지구의 땅을 그대로 본 떠 메타버스로 구현</li>
      <li>가상 부동산 플랫폼으로 원하는 지역의 땅을 자유롭게 사고 팔 수가 있다.</li>
    </ul>
  </li>
  <li>이외에도 제페토, 로블록스도 아이템 제작자가 판매할 수 있는 거래를 지원한다.</li>
</ul>

<h3 id="참조">참조</h3>
<hr />
<p>미래수업: 메가트렌드 메타버스 <br />
<a href="https://spri.kr/posts/view/23297?code=industry_trend">SPRI_소프트웨어정책연구소 포스트</a> <br />
<a href="https://m.blog.naver.com/PostList.naver?blogId=thesandboxkorea">더 샌드박스</a></p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="it" /><summary type="html"><![CDATA["메타버스 기술 관련"]]></summary></entry><entry><title type="html">[알고리즘] Backtracking 알고리즘</title><link href="http://localhost:4000/study/2023-04-25-algorithmStudy-backtracking/" rel="alternate" type="text/html" title="[알고리즘] Backtracking 알고리즘" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T20:15:03+09:00</updated><id>http://localhost:4000/study/algorithmStudy-backtracking</id><content type="html" xml:base="http://localhost:4000/study/2023-04-25-algorithmStudy-backtracking/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#백트래킹이란" id="markdown-toc-백트래킹이란">백트래킹이란?</a></li>
  <li><a href="#구현-방법" id="markdown-toc-구현-방법">구현 방법</a></li>
</ul>
<hr />
<h3 id="백트래킹이란">백트래킹이란?</h3>
<hr />
<ul>
  <li>해를 찾는 도중 해가 아니어서 막히면, 되돌아가서 다시 해를 찾아가는 기법을 말한다.</li>
  <li>주로 최적화 문제와 결정 문제를 푸는 방법이 된다.</li>
</ul>

<h3 id="구현-방법">구현 방법</h3>
<hr />
<ul>
  <li>해를 찾아가는 도중, 지금의 경로가 해가 될 것 같지 않으면 그 경로를 더 이상 가지 않고 되돌아간다.</li>
</ul>

<ol>
  <li>어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없다고 판단 하면 유망성이 없다, 그렇지 않다면 유망성이 있다고 한다.</li>
  <li>어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드 탐색을 시작한다. 이 과정을 <strong>가지치기</strong>라 한다.</li>
  <li>반대로 어떤 노드의 점검 결과가 유망하다고 결정되면 탐색을 계속한다.</li>
  <li>위 2,3 과정을 반복하면서 탐색을 계속한다.</li>
</ol>

<blockquote>
  <p>가지치기(pruning) <br />
-&gt; 유망하지 않는 노드가 포함된 경로는 더 이상 탐색X</p>
</blockquote>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="study" /><summary type="html"><![CDATA["내용 정리"]]></summary></entry><entry><title type="html">[알고리즘] D.P 알고리즘</title><link href="http://localhost:4000/study/2023-04-25-algorithmStudy-dp/" rel="alternate" type="text/html" title="[알고리즘] D.P 알고리즘" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T20:39:43+09:00</updated><id>http://localhost:4000/study/algorithmStudy-dp</id><content type="html" xml:base="http://localhost:4000/study/2023-04-25-algorithmStudy-dp/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#dpdynamic-programming이란" id="markdown-toc-dpdynamic-programming이란">DP(Dynamic Programming)이란?</a></li>
  <li><a href="#구현-방법" id="markdown-toc-구현-방법">구현 방법</a></li>
  <li><a href="#주의할-점" id="markdown-toc-주의할-점">주의할 점</a></li>
  <li><a href="#dp-활용방식" id="markdown-toc-dp-활용방식">DP 활용방식</a></li>
</ul>
<hr />
<h3 id="dpdynamic-programming이란">DP(Dynamic Programming)이란?</h3>
<hr />
<p>문제를 작은 문제로 (중복될 수도 있지만) 분할하여 분할된 문제의 해답을 기록해 놓은 후 더 큰 문제의 해답을 계산할 때 재사용하는 방법을 의미한다.</p>

<h3 id="구현-방법">구현 방법</h3>
<hr />
<p>DP 알고리즘의 4단계 분류</p>
<ol>
  <li>해답의 구조를 파악해 어떻게 부문제로 나눌 지 결정</li>
  <li>부문제의 해답을 어떻게 조합해 더 큰 문제의 해답을 만들 수 있는지 식을 마련</li>
  <li>작은 문제에서 큰 문제로 적당한 순서에 따라 해답을 계산하여 테이블에 저장하고 재사용하여 답을 계산</li>
  <li>위의 단계들이 원래 문제의 답을 항상 출력함을 증명하고 답을 리턴</li>
</ol>

<h3 id="주의할-점">주의할 점</h3>
<hr />
<ul>
  <li>DP Table을 만들 때 list index error에 대한 고려 항상 해줄 것</li>
</ul>

<h3 id="dp-활용방식">DP 활용방식</h3>
<hr />
<p><strong>Bottom-up 방식</strong></p>
<ul>
  <li>우리말로 ‘상향식’</li>
  <li>가장 작은 문제들부터 답을 찾아 가면서 마지막에는 전체 문제의 답을 구하는 방식</li>
  <li>반복문으로 구현하므로 시간과 메모리의 사용량이 상대적으로 적음</li>
</ul>

<p><strong>Top-down 방식</strong></p>
<ul>
  <li>우리말로 ‘하향식’</li>
  <li>큰 문제를 해결하기 위해 작은 문제를 호출하는 방식</li>
  <li>재귀호출을 통해 구한다. 함수 호출의 횟수를 줄이기 위해 메모이제이션 기법을 활용</li>
</ul>

<blockquote>
  <p>메모이제이션 기법 <br />
-&gt; 컴퓨터 프로그램이 동일한 계산을 반복할 때, 이전에 계산한 값을 메모리에 저장해놓는 방법
DP의 핵심이 되는 기술이다.</p>
</blockquote>

<p><strong>누적 합 활용 방식</strong></p>
<ul>
  <li>배열이 있을 때 해당 배열까지의 총 합을 따로 배열에 저장하는 방식</li>
  <li>시간복잡도 상 큰 이득을 가져다주는 경우가 많다</li>
</ul>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="study" /><summary type="html"><![CDATA["내용 정리"]]></summary></entry><entry><title type="html">[알고리즘] Dijkstra 알고리즘</title><link href="http://localhost:4000/study/2023-04-25-algorithmStudy-dijkstra/" rel="alternate" type="text/html" title="[알고리즘] Dijkstra 알고리즘" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T20:09:38+09:00</updated><id>http://localhost:4000/study/algorithmStudy-dijkstra</id><content type="html" xml:base="http://localhost:4000/study/2023-04-25-algorithmStudy-dijkstra/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#다익스트라-알고리즘이란" id="markdown-toc-다익스트라-알고리즘이란">다익스트라 알고리즘이란?</a></li>
  <li><a href="#구현-방법" id="markdown-toc-구현-방법">구현 방법</a></li>
  <li><a href="#구현-코드" id="markdown-toc-구현-코드">구현 코드</a></li>
  <li><a href="#참조" id="markdown-toc-참조">참조</a></li>
</ul>
<hr />
<h3 id="다익스트라-알고리즘이란">다익스트라 알고리즘이란?</h3>
<hr />
<p>다익스트라 알고리즘은 그래프에서 두 정점 간의 최단 경로를 찾는 알고리즘이다. 간선에 가중치가 주어진 방향 그래프를 대상으로만 사용할 수 있다는 특징이 있다.</p>

<p><img src="/assets/img/study/graph.png" alt="graph" /></p>

<p>이 알고리즘은 최단 경로를 구하는 과정에서 최단 경로 트리가 만들어지는데 최단 경로 트리는 출발점으로 정한 정점에서 각 정점까지의 최단 경로를 저장해 놓은 트리를 뜻한다.</p>

<p>예를 들어, 위 그림에서 a에서 i까지의 최단경로를 구한다면 다익스트라 알고리즘은 a에서 정점 g 혹은 h까지의 최단거리를 구한 후 다시 i까지를 계산한다. <br />
식으로 정리하면, 시작 정점에서 x 정점까지의 최단경로를 dist[x], 간선에 가중치를 x-&gt;y라 표현</p>

<blockquote>
  <p>dist[i] = min(dist[g] + g-&gt;i, dist[h] + h-&gt;i)</p>
</blockquote>

<p>즉, i까지의 최단경로를 구하려면 저 과정을 거쳐 각 정점마다 최단경로를 구하며 찾아간다. 그래서 우리는 i까지 가는 경로 내에 있는 정점들의 최단경로를 구할 수 있는 것이다.</p>

<h3 id="구현-방법">구현 방법</h3>
<hr />
<ul>
  <li>다익스트라 알고리즘은 우선 <strong>가중치가 주어진 방향 그래프</strong>에만 사용이 가능</li>
  <li>우선순위 큐를 이용해 최소가 되는 것부터 지워나가는 것이 중요하다.</li>
  <li>
    <p>만약 정점에 연결된 다른 모든 정점들의 가중치를 비교해나간다면 벨만-포드 알고리즘으로 시간복잡도가 O(N^3)까지 증가한다.</p>
  </li>
  <li>단계별 정리
    <ol>
      <li>출발 정점과 도착 정점을 정한다.</li>
      <li>정점과 정점 사이의 연결관계와 가중치를 저장해준다.</li>
      <li>우선순위 큐를 활용한다.</li>
      <li>우선순위 큐에 현재 정점에 연결된 정점의 정보와 가중치를 넣어준다.</li>
      <li>가중치가 적은 것부터 꺼내서 비교하고 업데이트 시켜준다.</li>
      <li>위 4,5번 과정을 반복한다.</li>
    </ol>
  </li>
</ul>

<h3 id="구현-코드">구현 코드</h3>
<hr />
<p><a href="https://www.acmicpc.net/problem/1753">백준 1753 최단경로 문제</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    import math
    import sys
    import heapq
    
    def dijkstra():
        heap = []
        heapq.heappush(heap, (0, K))
        while heap:
            currentWeight, currentVertex = heapq.heappop(heap)
    
            for nextVertex, weight in graph[currentVertex]:
                nextWeight = currentWeight + weight
                # 이미 해당 정점까지 계산된 경로가 지금 계산하려는 값보다 작다면 이미 최단경로이다
                if shortPath[nextVertex-1] &gt; nextWeight:  
                    shortPath[nextVertex-1] = nextWeight
                    heapq.heappush(heap, (nextWeight, nextVertex))
    
    # input
    input = sys.stdin.readline
    inf = math.inf
    
    V, E = map(int, input().split())
    K = int(input())
    
    graph = [[] for _ in range(V+1)]
    for _ in range(E):
        u, v, w = map(int, input().split())
        graph[u].append([v, w])
    
    # main
    shortPath = [inf for _ in range(V)]
    shortPath[K-1] = 0  # 시작점은 0
    dijkstra()

</code></pre></div></div>

<ul>
  <li>그래프 구현 시 2차원 배열을 생성해 가중치를 저장해주는 방식도 있으나 메모리가 많이 소모된다는 단점이 있다.</li>
</ul>

<h3 id="참조">참조</h3>
<hr />
<p><a href="https://www.youtube.com/watch?v=0NrlN88D9Fs&amp;list=PLsMufJgu5932XYejsOwcUDJ2F75f56nrl&amp;index=49&amp;pp=iAQB">신찬수 교수님 유튜브 강의영상</a> <br />
<a href="https://m.blog.naver.com/ndb796/221234424646">안경잡이개발자 님 네이버 블로그</a></p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="study" /><summary type="html"><![CDATA["내용 정리"]]></summary></entry><entry><title type="html">[알고리즘] BFS &amp;amp; DFS 알고리즘</title><link href="http://localhost:4000/study/2023-04-25-algorithmStudy-dfsbfs/" rel="alternate" type="text/html" title="[알고리즘] BFS &amp;amp; DFS 알고리즘" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T20:56:11+09:00</updated><id>http://localhost:4000/study/algorithmStudy-dfsbfs</id><content type="html" xml:base="http://localhost:4000/study/2023-04-25-algorithmStudy-dfsbfs/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#bfsbreadth-first-search" id="markdown-toc-bfsbreadth-first-search">BFS(Breadth-first search)</a>    <ul>
      <li><a href="#너비-우선-탐색이란" id="markdown-toc-너비-우선-탐색이란">너비 우선 탐색이란?</a></li>
      <li><a href="#구현-방법" id="markdown-toc-구현-방법">구현 방법</a></li>
      <li><a href="#구현-코드" id="markdown-toc-구현-코드">구현 코드</a></li>
    </ul>
  </li>
  <li><a href="#dfsdepth_first-search" id="markdown-toc-dfsdepth_first-search">DFS(Depth_First Search)</a>    <ul>
      <li><a href="#깊이-우선-탐색이란" id="markdown-toc-깊이-우선-탐색이란">깊이 우선 탐색이란?</a></li>
      <li><a href="#구현-방법-1" id="markdown-toc-구현-방법-1">구현 방법</a></li>
      <li><a href="#구현-코드-1" id="markdown-toc-구현-코드-1">구현 코드</a></li>
    </ul>
  </li>
</ul>
<hr />
<h2 id="bfsbreadth-first-search">BFS(Breadth-first search)</h2>

<h3 id="너비-우선-탐색이란">너비 우선 탐색이란?</h3>
<hr />
<p>시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법이다. 더 이상 방문하지 않은 정점이 없을 때까지 방문하지 않은 모든 정점들에 대해서 BFS 방식을 적용한다.</p>

<p>List로 구현할 경우 큐  방식을 활용해야만 레벨 순서대로 접근이 가능하다.</p>

<ul>
  <li>장점
    <ul>
      <li>출발 노드에서 목표 노드까지 최단 길이 경로를 보장한다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 많은 기억 공간을 필요로 하게 된다.</li>
    </ul>
  </li>
</ul>

<h3 id="구현-방법">구현 방법</h3>
<hr />
<p>BFS의 경우 queue를 이용해 구현하게 된다.</p>

<ol>
  <li>queue와 방문기록을 남겨줄 visited를 함께 만들어준다.</li>
  <li>queue에는 우선 루트 노드만을 저장한다.</li>
  <li>루프문을 돌면서 큐에서 노드를 꺼내 해당 노드와 연결된 노드들을 검사한다.</li>
  <li>만약 연결된 노드가 방문하지 않은 노드라면 결과에 추가해주고 queue에 연결된 노드를 넣어주는 것을 반복한다.</li>
  <li>위 3,4번 과정을 반복하면 너비 우선 탐색을 진행한다.</li>
</ol>

<h3 id="구현-코드">구현 코드</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    from collections import deque
    
    def BFS():
        while queue:
            node = queue.popleft()
            result2.append(node)
            for i in range(N+1):
                if arr[node][i] == 1 and visited2[i] == 0:
                    queue.append(i)
                    visited2[i] = 1
    
    # input
    N, M, V = map(int, input().split())
    
    arr = list([0] * (N+1) for _ in range(N+1))
    visited2 = [0] * (N+1)
    for _ in range(M):
        a, b = map(int, input().split())
        arr[a][b] = 1
        arr[b][a] = 1
    
    result2 = []
    visited2[V] = 1
    queue = deque()
    queue.append(V)
    BFS()

</code></pre></div></div>

<h2 id="dfsdepth_first-search">DFS(Depth_First Search)</h2>

<h3 id="깊이-우선-탐색이란">깊이 우선 탐색이란?</h3>
<hr />
<p>탐색 트리에서 최근에 첨가된 노드를 선택하고, 이 노드에 적용 가능한 다음 노드를 자식 노드로 첨가하며, 첨가된 자식 노드가 목표 노드일 때까지 같은 방식을 반복해 나가는 방식이다.</p>

<p>깊이 제한에 도달한 경우에는 최근에 첨가되었던 부모 노드로 되돌아와서, 다른 적용 가능한 자식 노드를 첨가하며 다시 진행한다.</p>

<p>장점</p>
<ul>
  <li>저장공간의 수요가 적다</li>
  <li>목표 노드가 깊은 단계에 있을 경우 해를 빠르게 구할 수 있다.</li>
</ul>

<p>단점</p>
<ul>
  <li>해가 없는 경로에 들어가도 끝까지 탐색을 하게 된다.</li>
  <li>얻어진 해가 최단 경로가 된다는 보장은 없다. 목표에 이르는 경로가 다수인 문제에 대해서 DFS는 해를 구하면 탐색을 끝내버리므로, 얻은 해가 최적이 아닐 수도 있다.</li>
</ul>

<h3 id="구현-방법-1">구현 방법</h3>
<hr />
<p>재귀를 이용하여 DFS를 하는 방법을 알아보겠다.</p>

<ol>
  <li>방문기록을 저장해 줄 visited를 만들어준다.</li>
  <li>루트 노드부터 탐색을 시작한다.</li>
  <li>현재 노드를 결과에 추가한다.</li>
  <li>현재 노드와 연결된 노드들을 검사한다.</li>
  <li>연결된 노드가 방문하지 않은 노드라면 우선 그 노드로 들어간다.</li>
  <li>계속해서 3,4,5번을 반복하다가 더 이상 탐색할 노드가 없다면 트리를 하나씩 올라온다.</li>
  <li>만약 다시 올라온 노드에 탐색할 노드가 남아있다면 다시 그 노드를 탐색하러 들어가는 것을 반복한다.</li>
</ol>

<h3 id="구현-코드-1">구현 코드</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    def DFS(V):
        result.append(V)
        visited[V] = 1
        for i in range(N+1):
            if arr[V][i] == 1 and visited[i] == 0:
                DFS(i)
    
    # input
    N, M, V = map(int, input().split())
    
    arr = list([0] * (N+1) for _ in range(N+1))
    visited = [0] * (N+1)
    for _ in range(M):
        a, b = map(int, input().split())
        arr[a][b] = 1
        arr[b][a] = 1
    
    result = []
    DFS(V)

</code></pre></div></div>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="study" /><summary type="html"><![CDATA["내용 정리"]]></summary></entry><entry><title type="html">[알고리즘] Binary Search 알고리즘</title><link href="http://localhost:4000/study/2023-04-25-algorithmStudy-binarysearch/" rel="alternate" type="text/html" title="[알고리즘] Binary Search 알고리즘" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T20:36:58+09:00</updated><id>http://localhost:4000/study/algorithmStudy-binarysearch</id><content type="html" xml:base="http://localhost:4000/study/2023-04-25-algorithmStudy-binarysearch/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#이진탐색이란" id="markdown-toc-이진탐색이란">이진탐색이란?</a></li>
  <li><a href="#구현-방법" id="markdown-toc-구현-방법">구현 방법</a></li>
  <li><a href="#구현-코드" id="markdown-toc-구현-코드">구현 코드</a></li>
</ul>
<hr />
<h3 id="이진탐색이란">이진탐색이란?</h3>
<hr />
<p>데이터가 정렬돼 있는 리스트에서 특정한 값을 찾아내기 위한 알고리즘 <br />
검색이 반복될 때마다 완전탐색과는 다르게 검색 범위를 절반으로 줄일 수 있는 장점이 있다.</p>

<h3 id="구현-방법">구현 방법</h3>
<hr />
<p>리스트 내 Left, Mid, right 값을 사용하며 찾고자 하는 값에 따라 Mid 값을 계속해서 계산해준다.</p>

<ol>
  <li>리스트 내 첫 인덱스를 Left(= 0)라 지정하고 가장 마지막을 Right(= len(list)-1)라고 지정한다.</li>
  <li>mid = (left + right) // 2, 계산해서 중간 인덱스값을 구한다.</li>
  <li>찾고싶은 값이 list[mid]보다 작으면 right = mid-1, 크다면 left = mid+1로 업데이트 시켜준다.</li>
  <li>2,3번 과정을 반복하면 찾고자하는 값을 구할 수 있다.</li>
</ol>

<p>이런 특징 때문에 이진탐색은 무조건 정렬되어있는 리스트에서만 사용이 가능하다.</p>

<h3 id="구현-코드">구현 코드</h3>
<hr />
<p>2가지 방법이 존재하며 재귀함수로 구현하는 것과 반복문으로 구현하는 것이 있다.</p>
<ol>
  <li>재귀 함수로 구현한 이진 탐색</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    def binary_search_recursive(list, target, left, right):
        if left &gt; right:
            return
    
        mid = (left + right) // 2
        
        if list[mid] == target:
            return mid
        elif list[mid] &gt; target:
            return binary_search_recursive(list, target, left, mid-1)
        else:
            return binary_search_recursive(list, target, left, mid - 1)

</code></pre></div></div>

<ol>
  <li>반복문으로 구현한 이진탐색</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    def binary_search_iter(list, target, left, right):
        while left &lt;= right:
            mid = (left + right) // 2
            
            if list[mid] == target:
                return mid
            elif list[mid] &gt; target:
                right = mid - 1
            else:
                left = mid + 1
        
        return

</code></pre></div></div>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="study" /><summary type="html"><![CDATA["내용 정리"]]></summary></entry><entry><title type="html">블록체인</title><link href="http://localhost:4000/it/2023-04-24-it-blockchain/" rel="alternate" type="text/html" title="블록체인" /><published>2023-04-24T00:00:00+09:00</published><updated>2023-04-25T19:28:24+09:00</updated><id>http://localhost:4000/it/it-blockchain</id><content type="html" xml:base="http://localhost:4000/it/2023-04-24-it-blockchain/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#정의" id="markdown-toc-정의">정의</a></li>
  <li><a href="#기술의-특징" id="markdown-toc-기술의-특징">기술의 특징</a></li>
  <li><a href="#핵심-구성-요소" id="markdown-toc-핵심-구성-요소">핵심 구성 요소</a></li>
  <li><a href="#블록체인-연결되는-방식" id="markdown-toc-블록체인-연결되는-방식">블록체인 연결되는 방식</a></li>
  <li><a href="#블록체인-네트워크-유형" id="markdown-toc-블록체인-네트워크-유형">블록체인 네트워크 유형</a></li>
  <li><a href="#참조" id="markdown-toc-참조">참조</a></li>
</ul>
<hr />
<h3 id="정의">정의</h3>
<hr />
<ul>
  <li>
    <p>블록체인은 블록들을 체인으로 연결해놓은 것</p>
  </li>
  <li><strong>블록</strong>이라고 하는 소규모 데이터들이 관리 대상 데이터를 P2P 방식을 기반으로 생성된 체인 형태의 연결고리 기반 분산 데이터 저장 환경에 저장하는 방식</li>
  <li>합의 없이 체인을 삭제하거나 수정할 수 없으므로 데이터가 시간 순서대로 일관성이 있음</li>
  <li>결과적으로 주문, 결제, 계정, 기타 트랜잭션을 추적하기 위해 변경 불가능한 분산 원장을 생성할 수 있음</li>
</ul>

<blockquote>
  <p>분산 원장이란? <br />
분산 원장은 탈중앙화의 특징을 가진 트랜잭션 데이터베이스를 뜻한다. 여기서 원장은 거래 장부를 뜻하는데 거래에 참여하는 각 당사자는
동일한 거래 장부 사본을 소유하며, 변경 내용은 모두 함께 업데이트 된다.</p>
</blockquote>

<h3 id="기술의-특징">기술의 특징</h3>
<hr />

<p><strong>탈중앙화</strong></p>

<ul>
  <li>중앙 집중식 엔티티에서 분산 네트워크로 이전</li>
  <li>투명성을 사용해 서로 간에 신뢰 필요성이 줄어듬</li>
</ul>

<p><strong>불변성</strong></p>

<ul>
  <li>공유 원장에 거래를 기록하면 참여자는 거래를 조작할 수 없다.</li>
  <li>오류가 발생했을 때는 이전 거래를 지우고 수정하는게 아니라 새로운 거래를 추가해야한다. <br />
(→ 네트워크 내 기록에는 두 개의 거래가 모두 남게된다)</li>
</ul>

<p><strong>합의</strong></p>

<ul>
  <li>거래 기록을 위한 참여자 동의에 관한 규칙을 설정</li>
  <li>과반수가 동의한 경우에만 새로운 거래를 기록 가능</li>
</ul>

<h3 id="핵심-구성-요소">핵심 구성 요소</h3>
<hr />

<p><strong>분산 원장</strong></p>

<ul>
  <li>블록체인 네트워크의 공유 데이터베이스</li>
</ul>

<p><strong>스마트 계약</strong></p>

<ul>
  <li>서드 파티를 지원할 필요 없이 비즈니스 계약을 자체 관리</li>
  <li>미리 정해진 조건이 충족되면 자동으로 실행되는 블록체인 시스템 내 프로그램</li>
</ul>

<p><strong>퍼블릭 키 암호화</strong></p>

<ul>
  <li>블록체인 네트워크 참여자를 고유하게 식별하는 보안 기능, 두 세트로 주어짐</li>
  <li>퍼블릭 키: 모든 사람에게 공통적으로 주어지는 키</li>
  <li>프라이빗 키: 구성원 고유의 키</li>
  <li>두 개의 키가 함께 작동하여 원장의 데이터 잠금을 해제하는 방식</li>
</ul>

<h3 id="블록체인-연결되는-방식">블록체인 연결되는 방식</h3>
<hr />

<p><img src="/assets/img/it/block.png" alt="blockchain" /></p>

<ul>
  <li>블록은 계속해서 만들어져 나온다.</li>
  <li>블록에 데이터를 저장해서 <em>블록체인</em>에 연결을 시키기 위해서는 일련의 과정이 필요하다.</li>
</ul>

<ol>
  <li>블록체인 내 연결할 블록의 해시값을 가져온다.</li>
  <li>저장하고 싶은 데이터를 해싱을 통해 해시값을 생성해낸다.</li>
  <li>두 개의 해시값에 채굴자가 Nonce 값을 찾아내 새로운 해시값을 생성해낸다.</li>
</ol>

<blockquote>
  <p>Nonce란? <br />
새로운 해시값은 제약조건이 존재하기 때문에 적절한 Nonce 값을 찾아줘야한다. <br />
적절한 Nonce 값을 찾기 위해서 계속해서 변경되기 때문에 ‘임시값’이라고도 한다.</p>
</blockquote>

<ul>
  <li>위 과정을 거쳐 블록들이 연결되기 때문에 이미 블록에 저장되어있는 데이터를 변경하려하면 데이터의 해시값이 변하게 된다.(불변성)</li>
</ul>

<h3 id="블록체인-네트워크-유형">블록체인 네트워크 유형</h3>
<hr />

<p><strong>퍼블릭 블록체인</strong></p>

<ul>
  <li>모든 사람이 블록체인에 참여할 수 있다.</li>
  <li>모든 구성원은 Read &amp; Write 과 Validation을 할 권리를 갖는다</li>
  <li>암호화폐의 대부분은 퍼블릭 블록체인을 사용한다(ex. Bitcoin, Ethereum)</li>
</ul>

<p><strong>프라이빗 블록체인</strong></p>

<ul>
  <li>단일 조직의 관리형 블록체인이라고도 불린다.</li>
  <li>해당 조직에서 구성원과 권한을 결정할 수 있다.</li>
  <li>따라서, 접근 제한을 위해 부분적으로만 분산시켜 놓는 특징이 있다</li>
</ul>

<p><strong>하이브리드 블록체인</strong></p>

<ul>
  <li>프라이빗 &amp; 퍼블릭 네트워크 결합</li>
  <li>기존 퍼블릭 시스템에 권한 기반 프라이빗 시스템을 설정하는 것</li>
  <li>블록체인 내 특정 데이터에 대한 액세스는 제어하면서 나머지 데이터는 공개</li>
  <li>
    <p>예를 들어, 퍼블릭 회원이 프라이빗 거래가 완료되었는지를 확인할 수는 있지만 프라이빗 거래 내역에 접근해 거래 내용을 확인하는 행위 등을 제한할 수 있게 하는 방법이 있다.</p>
  </li>
  <li>장점
    <ul>
      <li>폐쇄형 생태계에서 작동하므로 정보 유출에 대한 위험이 없다</li>
      <li>목적에 따라 규칙을 바꿀 수 있다</li>
      <li>일정한 노드만 참여가 가능하기 때문에 트랜잭션 비용이 저렴하다.</li>
    </ul>
  </li>
</ul>

<h3 id="참조">참조</h3>
<hr />
<p><a href="https://aws.amazon.com/ko/what-is/blockchain/?aws-products-all.sort-by=item.additionalFields.productNameLowercase&amp;aws-products-all.sort-order=asc">AWS 블록체인 관련 문서</a> <br />
<a href="https://www.sap.com/korea/insights/what-is-blockchain.html">SAP 블록체인 관련 문서</a> <br />
<a href="https://www.youtube.com/watch?v=TljQRfHRId8&amp;list=PL7jH19IHhOLOJfXeVqjtiawzNQLxOgTdq">노마드 코더 영상</a></p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="it" /><summary type="html"><![CDATA["블록체인 기술 관련"]]></summary></entry><entry><title type="html">[Jekyll] GitHub 블로그 개발일지(2)</title><link href="http://localhost:4000/jekyll/2023-04-21-jekyll-theme/" rel="alternate" type="text/html" title="[Jekyll] GitHub 블로그 개발일지(2)" /><published>2023-04-21T00:00:00+09:00</published><updated>2023-04-26T21:23:38+09:00</updated><id>http://localhost:4000/jekyll/jekyll-theme</id><content type="html" xml:base="http://localhost:4000/jekyll/2023-04-21-jekyll-theme/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#21-새로운-테마-선정" id="markdown-toc-21-새로운-테마-선정">2.1 새로운 테마 선정</a></li>
  <li><a href="#22-새로운-테마-적용" id="markdown-toc-22-새로운-테마-적용">2.2 새로운 테마 적용</a></li>
  <li><a href="#23-주의할-점" id="markdown-toc-23-주의할-점">2.3 주의할 점</a></li>
</ul>

<hr />
<h3 id="21-새로운-테마-선정">2.1 새로운 테마 선정</h3>
<hr />
<ul>
  <li><a href="https://velog.io/@juxgsiroo/github-page-pt2">juxgsiroo 님 Velog</a> 추천 참조</li>
</ul>

<blockquote>
  <p>기존에 쓰던 테마가 너무 단순하고 밋밋하다는 생각이 들던 때에 새로운 테마를 구경하게 되었고 지금까지 했던걸
과감히 버리고서라도 변경하기로 결정했다</p>
</blockquote>

<h3 id="22-새로운-테마-적용">2.2 새로운 테마 적용</h3>
<ul>
  <li>기존에 저장했던 Markdown 폴더들을 전부 따로 빼준 뒤 레포지토리를 비워주었다</li>
  <li>이전에 했던 것 처럼 Hydejack을 Zip으로 가져와 레포지토리에 넣어주는 방식을 활용</li>
  <li><a href="https://github.com/hydecorp/hydejack">hydecorp/hydejack Repository</a></li>
  <li>
    <p>당연히 해당 repository를 가져오면 될 것이라 생각했지만 이 파일에는 gemfile이 존재하지 않는다</p>

    <p><img src="/assets/img/jekyll/noGem.png" alt="Nogem" /></p>
  </li>
</ul>

<blockquote>
  <p>gemfile이 없다면 ‘bundle exec jekyll serve’ 를 실행 시
‘Could not locate Gemfile’ 이라는 Error가 발생한다.</p>
</blockquote>

<ul>
  <li>해결방법은 간단하다</li>
  <li><a href="https://github.com/hydecorp/hydejack-starter-kit">hydecorp/hydejack-starter-kit</a></li>
  <li>해당 레포지토리로 이동하면 스타터킷 답게 다 포함되어있는 것을 확인할 수 있다.</li>
  <li>(추가) masterkit으로 다운받았지만 현재 버전과 다른 점이 많아 버전에 맞춰 다운받는것이 편할 수도 있다.</li>
</ul>

<h3 id="23-주의할-점">2.3 주의할 점</h3>
<hr />
<ul>
  <li>minimal mistakes 테마를 사용하던 때와는 다르게 조심해줘야할 점들이 많았다.</li>
  <li>많이 안 쓰는 테마여서 웬만해서는 Guide나 Demo site와 코드를 비교해보며 알아가야했다.</li>
</ul>

<p><strong>2.3.1</strong> _config.yml Theme 설정</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
    # Theme
    # ---------------------------------------------------------------------------------------
    
    #theme: jekyll-theme-hydejack
    remote_theme: hydecorp/hydejack@v9

</code></pre></div></div>

<ul>
  <li>해당 코드를 보면 theme와 remote_theme가 나누어져있다</li>
  <li>local에서 테스트 해볼 때는 theme를 주석처리를 풀고 remote_theme를 주석처리</li>
  <li>서버에 올릴 떄는 위의 예시코드처럼 사용해주어야함</li>
</ul>

<blockquote>
  <p>따로 layout 폴더를 만들지 않고 Jekyll에서 기본으로 주어지는 layout plugin을 사용하기 때문에
상황에 맞게 바꿔주지 않으면 해당 부분이 로드되지 않는다.</p>
</blockquote>

<p><strong>2.3.2</strong> 폴더 경로 설정</p>
<ul>
  <li>가장 시간을 많이 잡아먹었고 스트레스 받았던 부분이다.
    <ul>
      <li>아래와 같이 Local에서는 제대로 동작해도 서버에 올리면 다르게 동작하는 등 많은 문제점이 발생했다.</li>
    </ul>

    <p><img src="/assets/img/jekyll/pathError.png" alt="Error" /></p>
  </li>
  <li>우선 _featured_categories 폴더에 카테고리 별로 분류를 해주기 위한 Markdown 파일을 작성</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
    ---
    # Featured tags need to have either the `list` or `grid` layout (PRO only).
    layout: list
    
    # The title of the tag's page.
    title: Algorithm
    
    # The name of the tag, used in a post's front matter (e.g. tags: [&lt;slug&gt;]).
    slug: algorithm
    
    # (Optional) Write a short (~150 characters) description of this featured tag.
    description: &gt;
        알고리즘 문제 풀이
    
    # (Optional) You can disable grouping posts by date.
    # no_groups: true
    
    sitemap: false
    ---

</code></pre></div></div>

<ul>
  <li>
    <p>다음으로 카테고리에 post를 올리기 위해서는 해당 사진처럼 해준다</p>

    <p><img src="/assets/img/jekyll/path.png" width="450px" height="100px" /></p>
  </li>
  <li>
    <p>주의해야할 점은 _config 파일에 해당 포맷대로 파일명을 작성해줘야 인식한다는 점이다.</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    # Format of the permalinks
    permalink:             /:categories/:year-:month-:day-:title/

</code></pre></div></div>

<blockquote>
  <p>이외에도 필자는 Blog라는 키워드는 CHANGELOG.md 파일의 특정 부분과 문제를 일으켜서 사용 시 버그가 발생하는 문제점이 있었다.
누군가는 이글을 보며 조금이라도 편하게 Hydejack 테마를 이용할 수 있기를 바라는 마음에 작성한다.</p>
</blockquote>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="jekyll" /><summary type="html"><![CDATA["빠르게 찾아온 더 이쁜 테마에 대한 열망"]]></summary></entry><entry><title type="html">[Programmers] 단속 카메라</title><link href="http://localhost:4000/algorithm/2023-04-20-algorithm-%EB%8B%A8%EC%86%8D%EC%B9%B4%EB%A9%94%EB%9D%BC/" rel="alternate" type="text/html" title="[Programmers] 단속 카메라" /><published>2023-04-20T00:00:00+09:00</published><updated>2023-04-21T13:32:42+09:00</updated><id>http://localhost:4000/algorithm/algorithm-%EB%8B%A8%EC%86%8D%EC%B9%B4%EB%A9%94%EB%9D%BC</id><content type="html" xml:base="http://localhost:4000/algorithm/2023-04-20-algorithm-%EB%8B%A8%EC%86%8D%EC%B9%B4%EB%A9%94%EB%9D%BC/"><![CDATA[<blockquote>
  <p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/42884">https://school.programmers.co.kr/learn/courses/30/lessons/42884</a></p>
</blockquote>

<h3 id="문제-해결-방안">문제 해결 방안</h3>
<hr />
<ul>
  <li>이전에 비슷한 문제를 풀어봐서 Greedy 알고리즘 사용을 바로 결정</li>
  <li>카메라를 최대한 많은 루트를 포함하는 지점에 설치하는 것을 반복</li>
  <li><strong>고려했던 점 두가지</strong>
    <ol>
      <li>출발점이나 끝나는 지점에 꽂았을 때 나오는 결과가 최적해가 될 수 있는가</li>
      <li>만약 그렇다면 최소한의 계산으로 최적해를 구하는 방법은 무엇인가</li>
    </ol>
  </li>
</ul>

<h3 id="routes-정렬">routes 정렬</h3>
<hr />
<ul>
  <li>주어진 routes 정보를 그대로 이용하기보다 출발점을 기준으로 정렬해주기로 결정</li>
  <li>정렬식은 람다 함수를 이용</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  routes = sorted(routes, key = lambda x : x[0])

</code></pre></div></div>

<h3 id="greedy-알고리즘-적용">greedy 알고리즘 적용</h3>
<hr />
<ul>
  <li>출발점을 설치 지점으로 지정</li>
  <li>가장 출발점이 나중인 구간부터 탐색 시작</li>
  <li>출발점에 설치를 했을 때 더 빠르게 시작하는 루트들을 탐색하며 겹치는 루트를 탐색</li>
  <li>현재 설치된 카메라로 단속이 가능한 구간은 가능하다는 것을 기록</li>
  <li>
    <p>단속이 가능한 구간은 제외하면서 남은 구간으로 해당 작업을 반복</p>
  </li>
  <li>해당 방법은 출발점에 설치를 하지 않는다면 그 구간은 단속할 수 있는 방법이 없으므로 <strong>최적해 조건 만족</strong></li>
  <li>부분 문제에 대해서도 해결이 가능한 방법</li>
</ul>

<h3 id="전체-코드">전체 코드</h3>
<hr />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  def solution(routes):
      answer = 0
      install = [0 for _ in range(len(routes))]
      
      routes = sorted(routes, key = lambda x : x[0])
      
      for i in range(len(routes)-1, -1, -1):
          if install[i]:
              continue
          
          install[i] = 1
          spot = routes[i][0]
          for j in range(i-1, -1, -1):
              if routes[j][0] &lt;= spot &lt;= routes[j][1]:
                  install[j] = 1
              else:
                  break
          print(spot)
          answer += 1
      
      return answer

</code></pre></div></div>

<h3 id="문제-풀이-후기">문제 풀이 후기</h3>
<blockquote>
  <p>람다식을 활용한다는 생각을 하지못해 많은 시간을 소비했다.
총 소요 시간 1H 30M</p>
</blockquote>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="algorithm" /><summary type="html"><![CDATA["Greedy 알고리즘 활용 문제"]]></summary></entry></feed>