<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-04-28T17:43:09+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hunnibs</title><subtitle>About my work history &amp; review
</subtitle><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><entry><title type="html">[BOJ] 15686_치킨배달</title><link href="http://localhost:4000/algorithm/2023-04-28-algorithm-BOJ_15686/" rel="alternate" type="text/html" title="[BOJ] 15686_치킨배달" /><published>2023-04-28T00:00:00+09:00</published><updated>2023-04-28T17:43:09+09:00</updated><id>http://localhost:4000/algorithm/algorithm-BOJ_15686</id><content type="html" xml:base="http://localhost:4000/algorithm/2023-04-28-algorithm-BOJ_15686/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#문제-해결-과정" id="markdown-toc-문제-해결-과정">문제 해결 과정</a></li>
  <li><a href="#순열permutation과-조합combination" id="markdown-toc-순열permutation과-조합combination">순열(Permutation)과 조합(Combination)</a></li>
  <li><a href="#전체-코드" id="markdown-toc-전체-코드">전체 코드</a></li>
  <li><a href="#문제풀이후기" id="markdown-toc-문제풀이후기">문제풀이후기</a></li>
</ul>
<hr />
<h3 id="문제-해결-과정">문제 해결 과정</h3>
<hr />
<ul>
  <li>잘못된 접근 방법</li>
</ul>

<p>처음 문제를 봤을 때는 2차원 배열에 장소를 찾는 문제이므로 BFS 혹은 DFS 문제일 것이라고 생각했다. <br />
집에서 가장 가까운 치킨집으로의 최단거리를 구하고 그렇게 나온 최단거리 치킨집이 M값보다 작다면 그 결과값을 출력하고 아니라면 가장 적게 가는 치킨집을 줄이는 방식으로 구현하려했다.</p>

<p>이 방법은 ‘어떤’ 치킨집에 ‘최단경로’로 도착해야하고 만약 M값보다 치킨집이 더 많다면 가장 적게 방문했다는 정보를 기준으로 치킨집을 그냥 도로인 0으로 줄여야하는 로직을 짜야했다.</p>

<p>결론부터 이야기하자면 문제를 제대로 읽지않아 조건을 제대로 활용하지 못하고 첫 생각부터 잘못했다.</p>

<ul>
  <li>실제 풀이 방법</li>
</ul>

<p>문제에는 조건이 하나 주어진다.</p>

<blockquote>
  <p>임의의 두 칸 (r1, c1)과 (r2, c2) 사이의 거리는 |r1-r2| + |c1-c2|로 구한다. <br />
집에서 치킨집까지의 경로 <strong>Dist = abs(r1-r2) + abs(c1-c2)</strong></p>
</blockquote>

<p>즉, 치킨집과 집의 위치 좌표를 알고있다면 어떤 치킨집이 가장 가까운지 알 수 있고 최단 경로는 (치킨집의 개수 * 집의 개수) 연산 만으로 계산해낼 수 있다.</p>

<p>여전히 문제인 것은 치킨집을 M값보다 작게 만들어줘야한다는 점이었는데 이는 <strong>조합</strong>을 이용해서 해결했다. <br />
치킨집 위치좌표들을 조합을 이용해 M개 만큼씩 만들어주고 이를 전부 돌아서 가장 최단경로인 경우를 출력해주면 된다.</p>

<h3 id="순열permutation과-조합combination">순열(Permutation)과 조합(Combination)</h3>
<hr />
<ul>
  <li>수학에서 조합은 유한 개의 원소에서 주어진 수만큼의 원소들을 고르는 방법이다.</li>
  <li>
    <p>수학에서 순열은 유한 개의 원소에서 주어진 수만큼의 원소들을 고르는데 고르는 원소의 순서에 따라 다르게 취급하는 방법이다.</p>
  </li>
  <li>파이썬에서는 라이브러리를 제공한다.</li>
</ul>

<p><strong>순열</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    from itertools import permutations
    
    items = [1, 2, 3, 4]
    perm = list(permutations(items, num)  # num에는 몇 개를 묶을건지를 결정해주는 변수
    # [(1, 2), (1, 3), (1, 4), (2, 1), (2, 3), (2, 4), (3, 1), (3, 2), (3, 4), (4, 1), (4, 2), (4, 3)]

</code></pre></div></div>

<p><strong>조합</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    from itertools import combinations
    
    items = [1, 2, 3, 4]
    comb = list(combinations(items, num)  # num에는 몇 개를 묶을건지를 결정해주는 변수
    # [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] 

</code></pre></div></div>

<h3 id="전체-코드">전체 코드</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    import sys
    from itertools import combinations
    from math import inf
    
    # input
    input = sys.stdin.readline
    
    N, M = map(int, input().split())
    
    street = []
    for _ in range(N):
        street.append(list(map(int, input().split())))
    
    # main
    chicken = []
    house = []
    for x in range(N):
        for y in range(N):
            if street[x][y] == 2:
                chicken.append([x, y])
            elif street[x][y] == 1:
                house.append([x, y])
    
    min_chickenHouse = list(combinations(chicken, M))
    result = inf
    for i in range(len(min_chickenHouse)):
        total_dist = 0
        for x in range(len(house)):
            r1, c1 = house[x]
            dist = inf
            for y in range(len(min_chickenHouse[i])):
                r2, c2 = min_chickenHouse[i][y]
                dist = min(dist, abs(r1-r2)+abs(c1-c2))
            total_dist += dist
            if total_dist &gt; result:
                break
    
        if total_dist &lt; result:
            result = total_dist
    
    print(result)

</code></pre></div></div>

<h3 id="문제풀이후기">문제풀이후기</h3>
<hr />
<p>격자 문제가 주어지면 자동으로 DFS, BFS 쓸 생각부터 하게된다. 물론 많은 문제가 그렇지만 조금 문제를 잘 읽어보고 확실하게 결정해서 생각하는 것이 필요할 것 같다. <br />
총 소요시간: 1H 10M</p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="algorithm" /><summary type="html"><![CDATA["조합 활용 문제"]]></summary></entry><entry><title type="html">클라우드</title><link href="http://localhost:4000/it/2023-04-27-it-cloud/" rel="alternate" type="text/html" title="클라우드" /><published>2023-04-27T00:00:00+09:00</published><updated>2023-04-28T14:00:32+09:00</updated><id>http://localhost:4000/it/it-cloud</id><content type="html" xml:base="http://localhost:4000/it/2023-04-27-it-cloud/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#정의" id="markdown-toc-정의">정의</a></li>
  <li><a href="#클라우드-4가지-유형" id="markdown-toc-클라우드-4가지-유형">클라우드 4가지 유형</a></li>
  <li><a href="#클라우드-사용-이점" id="markdown-toc-클라우드-사용-이점">클라우드 사용 이점</a></li>
  <li><a href="#클라우드-배포-유형" id="markdown-toc-클라우드-배포-유형">클라우드 배포 유형</a></li>
  <li><a href="#참조" id="markdown-toc-참조">참조</a></li>
</ul>
<hr />
<h3 id="정의">정의</h3>
<hr />
<p><strong>클라우드</strong>는 인터넷을 통해 엑세스할 수 있는 서버와 이러한 서버에서 작동하는 소프트웨어와 데이터베이스를 의미한다. <br />
클라우드 서버는 전 세계 데이터 센터에 위치하고 있고 자체 서버에서 소프트웨어를 실행시키는 것이 아니라 클라우드 내에서 제공해주기 때문에 사용자와 기업은 어디에서든 다양한 장치를 이용하여 파일과 애플리케이션에 접근할 수 있습니다.</p>

<h3 id="클라우드-4가지-유형">클라우드 4가지 유형</h3>
<hr />
<p>클라우드의 서비스 모델은 사용 목적에 따라 크게 4가지로 나누어집니다.</p>

<p align="center"><img src="/assets/img/it/cloudService.png" width="500px" height="300px" title="px(픽셀) 크기 설정" alt="cloudService" /></p>

<p>우선 서비스형에 대해 이해를 할 필요가 있다.</p>
<blockquote>
  <p>서비스형(as-a-Service)이란?      <br />
클라우드 서비스 모델에 서비스형이 붙는 이유는 클라우드가 기본적으로 고객을 대신해서 클라우드 컴퓨팅 서비스를 관리하기 때문이다.
그래서 고객은 서버 관리보다는 다른 더 중요한 업무에 중요할 수 있는 이점이 있다.</p>
</blockquote>

<p>다음은 클라우드 서비스의 4가지 유형이다.</p>
<ol>
  <li>
    <p>IaaS(Infrastructure-as-a-Service)_서비스형 인프라: <br />
이 모델은 클라우드로부터 필요한 서버와 저장소를 제공한다. 기업은 제공받은 클라우드 인프라를 활용해 자체 응용 프로그램을 구축할 수 있게 된다. <br />
쉽게 정리하면 집을 짓기 위해 땅을 빌렸지만 땅 이외의 모든 것은 고객이 해결하는 것이다.</p>
  </li>
  <li>
    <p>Paas(Platform-as-a-Service)_서비스형 플랫폼: <br />
이 모델은 클라우드로부터 필요한 서버와 저장소를 빌리고 개발에 필요한 모든 것들을 제공한다. Iaas보다는 더 간편하게 개발을 시작하고 자체 응용프로그램을 구출할 수 있다.
이 모델은 집을 짓기 위해 땅만 빌리는 Iaas 방식에 추가로 집을 짓기 위한 도구까지 빌리는 것이다. <br />
ex) Heroku, Microsoft Azure</p>
  </li>
  <li>
    <p>Saas(Software-as-a-Service)_서비스형 소프트웨어: <br />
이 모델은 클라우드가 모든 것을 제공하는 것이다. 클라우드 서비스 형태 중 가장 완성된 형태의 클라우드 서비스라고 볼 수 있다. <br />
간단하게 지금까지 뭔가를 빌려서 직접 집을 만들었다면 이 방법은 완성된 집 자체를 빌리는 방식이라고 얘기할 수 있다. <br />
ex) 마이크로소프트365, 드롭박스, 슬랙 등</p>
  </li>
  <li>
    <p>Faas(Function-as-a-Service)_서비스로서의 기능: <br />
이 모델은 나온지 얼마 되지 않은 이벤트 기반 실행 모델로서, 결론부터 말하면 집 전체를 빌리는 것이 아니라 목적에 맞게 일부만 빌리는 것이다. <br />
이는 더 낮은 비용으로 간편하게 개발을 할 수 있다는 장점이 있다.</p>
  </li>
</ol>

<h3 id="클라우드-사용-이점">클라우드 사용 이점</h3>
<hr />
<ul>
  <li>
    <p>개발 속도 향상: <br />
가장 중요한 부분 중 하나로 클라우드 컴퓨팅을 사용하면 개발자들이 리소스를 사용하기 위해 걸리는 시간이 단축된다.</p>
  </li>
  <li>
    <p>데이터 센터 운영 및 유지 관리 비용 절감: <br />
서버를 따로 관리할 필요 없이 클라우드 서비스에 맡기면 되므로 온전히 사용자만의 소프트웨어를 만들고 배포하는데 집중할 수 있다.</p>
  </li>
  <li>
    <p>용량 추정 불필요: <br />
필요한 인프라 용량을 추정할 필요없이 개발단계에 따라 확장하거나 축소하는 것이 가능하다.</p>
  </li>
  <li>
    <p>배포의 용이함:
클라우드 데이터 센터는 전세계 어디에나 있기 때문에 세계 곳곳에 손쉽게 배포가 가능하다.</p>
  </li>
</ul>

<h3 id="클라우드-배포-유형">클라우드 배포 유형</h3>
<hr />
<ul>
  <li>
    <p>퍼블릭 클라우드: <br />
클라우드 컴퓨팅 배포의 가장 일반적인 유형이다. 클라우드 리소스를 클라우드 서비스 공급자가 소유하고 운영하며 인터넷을 통해 제공한다. <br />
퍼블릭 클라우드는 다수의 조직에서 공유해서 여러 회사에서 클라우드 내 서버 공간을 임대하는 방식이다.</p>
  </li>
  <li>
    <p>프라이빗 클라우드: <br />
단일 조직에서 독점적으로 사용하는 클라우드이다. 프라이빗 클라우드는 조직의 현장 데이터 센터에 있거나 서비스 공급자가 호스팅하는 방식을 활용한다.<br />
서비스와 인프라가 항상 프라이빗 네트워크에서 유지 관리되어 전용으로 사용할 수 있어 보안이 철저하다.</p>
  </li>
  <li>
    <p>하이브리드 클라우드: <br />
조직은 프라이빗 클라우드 내 데이터 센터에 매우 중요한 데이터를 유지하면서 퍼블릭 클라우드로 특정 워크로드를 실행하여 퍼블릭 클라우드에서 제공하는 유연성을 가지고 있다.</p>
  </li>
</ul>

<h3 id="참조">참조</h3>
<hr />
<p><a href="https://docs.aws.amazon.com/ko_kr/whitepapers/latest/aws-overview/what-is-cloud-computing.html">AWS</a> <br />
<a href="https://www.redhat.com/ko/topics/cloud-computing/what-are-cloud-services#:~:text=%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%EB%8A%94%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%20%EC%A0%84%EC%B2%B4%EC%97%90%EC%84%9C,%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C%20%EC%BB%B4%ED%93%A8%ED%8C%85%EC%9D%84%20%EC%A7%80%EC%9B%90%ED%95%A9%EB%8B%88%EB%8B%A4.">Red Hat</a> <br />
<a href="https://www.cloudflare.com/ko-kr/learning/cloud/what-is-the-cloud/">Cloudflare</a> <br />
<a href="https://azure.microsoft.com/ko-kr/resources/cloud-computing-dictionary/what-are-private-public-hybrid-clouds/#deployment-options">Microsoft Azure</a></p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="it" /><summary type="html"><![CDATA["클라우드 기술 관련"]]></summary></entry><entry><title type="html">메타버스</title><link href="http://localhost:4000/it/2023-04-26-it-metaverse/" rel="alternate" type="text/html" title="메타버스" /><published>2023-04-26T00:00:00+09:00</published><updated>2023-04-27T10:31:47+09:00</updated><id>http://localhost:4000/it/it-metaverse</id><content type="html" xml:base="http://localhost:4000/it/2023-04-26-it-metaverse/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#정의" id="markdown-toc-정의">정의</a></li>
  <li><a href="#메타버스의-4가지-유형" id="markdown-toc-메타버스의-4가지-유형">메타버스의 4가지 유형</a></li>
  <li><a href="#특징" id="markdown-toc-특징">특징</a></li>
  <li><a href="#메타버스가-활성화되기-위한-방안" id="markdown-toc-메타버스가-활성화되기-위한-방안">메타버스가 활성화되기 위한 방안</a></li>
  <li><a href="#참조" id="markdown-toc-참조">참조</a></li>
</ul>
<hr />
<h3 id="정의">정의</h3>
<hr />
<p>메타버스(metaverse)는 ‘웹상에서 아바타를 이용하여 사회, 경제, 문화적 활동을 하는 활동처럼 가상 세계와 현실 세계의 경계가 허물어지는 것을 이르는 말’이다.</p>

<h3 id="메타버스의-4가지-유형">메타버스의 4가지 유형</h3>
<hr />
<p>메타버스는 간단하게는 가상세계를 뜻하는 개념이지만 4개로 분류하여 훨씬 더 확장적인 의미로 사용하고 있다.</p>

<p align="center"><img src="/assets/img/it/metaverse.jpg" width="400px" height="400px" title="px(픽셀) 크기 설정" alt="metaverse" /></p>

<ol>
  <li>
    <dl>
      <dt>AR(AUGMENTED REALITY)</dt>
      <dd>증강현실을 뜻하며 현실의 이미지나 배경에 3차원 가상 이미지를 겹쳐서 하나의 영상으로 보여주는 기술 <br />
ex) 포켓몬고, Google SKY Map</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>LIFELOGGING</dt>
      <dd>개인의 일상을 인터넷 또는 스마트 기기에 기록하는 것으로, ‘일상의 디지털화’라고 할 수 있다. <br />
ex) 스마트밴드, SNS</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>MIRROR WORLD</dt>
      <dd>AR과 달리 현실세계를 인터넷에 3차원 CG로 재현하여 시뮬레이션 등을 통한 의사결정 증강지원 시스템이다.  <br />
ex) 구글어스</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>VR(VIRTUAL WORLDS)</dt>
      <dd>흔히 아는 가상현실을 뜻하며 컴퓨터 등을 사용한 인공적인 기술로 만들어낸 실제와 유사하지만 실제가 아닌 어떤 특정한 환경이나 상황 혹은 그 기술 자체를 의미한다. <br />
ex) 제페토, 로블록스</dd>
    </dl>
  </li>
</ol>

<h3 id="특징">특징</h3>
<hr />
<p><strong>- NFT의 활용이 가능하다!</strong></p>
<ul>
  <li>디지털 아트의 소유권을 공식화하는 방법으로 시작</li>
  <li>현재는 디지털 부동산 등 다른 유형의 디지털 자산마저 NFT로 만들어졌다</li>
  <li>더 샌드박스, 제페토, 로블록스 등 대부분의 메타버스 플랫폼에서 이를 도입해 일부 디지털 자산을 NFT로 만들었다</li>
</ul>

<blockquote>
  <p>NFT(non-fungible token)란? <br />
대체 불가능한 토큰을 뜻한다.
블록체인에 저장된 데이터 단위로 흔히 아는 암호화폐와는 다르게 고유하면서 상호 교환할 수 없는 특징을 가진다. <br />
쉽게 말하면 암호화폐마다 고유한 번호가 매겨져있기 때문에 각각이 다른 가치를 가지고 대체가 될 수 없다는 것을 뜻한다.
그래서 NFT는 한 번 발행되면 제 3자가 이를 복제하거나 위조할 수가 없고 소유권과 거래내역이 명시되어 ‘디지털 소유 증명서’처럼 활용이 가능하다.</p>
</blockquote>

<p><img src="/assets/img/it/sandbox.png" alt="sandbox" /></p>

<ul>
  <li>더 샌드박스 NFT를 예시로 들었을 때 모든 토큰은 각자 고유의 가치와 활용성을 지니고 상호작용 할 수 있도록 디자인되었다.</li>
  <li>이는 독창성을 입증할 수 있기 때문에 가치나 유일성을 입증할 수 있는 좋은 방법으로 보인다.
<br /></li>
</ul>

<p><strong>- 가상세계에서의 경제활동이 가능하다!</strong></p>
<ul>
  <li>메타버스는 NFT를 활용하는 것 이외에도 경제활동이 가능하다.</li>
  <li>NFT가 자신의 디지털 자산이라면 그것을 사고 팔기 위한 경제활동이 가능하다는 뜻</li>
  <li>경제활동을 하는 가장 흥미있는 메타버스는 ‘어스2’
    <ul>
      <li>어스2는 지구의 땅을 그대로 본 떠 메타버스로 구현</li>
      <li>가상 부동산 플랫폼으로 원하는 지역의 땅을 자유롭게 사고 팔 수가 있다.</li>
    </ul>
  </li>
  <li>이외에도 제페토, 로블록스도 아이템 제작자가 판매할 수 있는 거래를 지원한다.</li>
</ul>

<h3 id="메타버스가-활성화되기-위한-방안">메타버스가 활성화되기 위한 방안</h3>
<hr />
<ol>
  <li>
    <p>기술의 발전이 필요하다. <br />
가상현실 기반 영화 레디플레이어원처럼 메타버스 상에서 더 많은 경험을 할 수 있다면 사람들의 흥미를 돋울 수 있을 것이다.</p>
  </li>
  <li>
    <p>안전성이 중요하다. <br />
예를 들어, 최근 인기를 끌었던 본디라는 플랫폼은 개인정보유출 문제로 인해 단기간에 이용자들이 급감하는 일을 겪었다. 
따라서 메타버스를 활성화시키기 위해서는 보안 문제를 확실히 해결해야할 필요가 있다.</p>
  </li>
  <li>
    <p>주 타켓층을 늘려야한다. <br />
메타버스의 주요 타켓은 현재 한정적이다. 예를 들어, 디자이너, 인플루언서, 10대들로 그들을 제외한 나머지 사람들의 참여가 저조한 편이다.
이를 해결하기 위해서는 메타버스 내에서 그들의 커리어를 쌓거나 혹은 흥미를 돋울 수 있는 다양한 경험을 제공할 필요가 있어보인다.</p>
  </li>
</ol>

<h3 id="참조">참조</h3>
<hr />
<p>미래수업: 메가트렌드 메타버스 <br />
<a href="https://spri.kr/posts/view/23297?code=industry_trend">SPRI_소프트웨어정책연구소 포스트</a> <br />
<a href="https://m.blog.naver.com/PostList.naver?blogId=thesandboxkorea">더 샌드박스</a></p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="it" /><summary type="html"><![CDATA["메타버스 기술 관련"]]></summary></entry><entry><title type="html">[알고리즘] BFS &amp;amp; DFS 알고리즘</title><link href="http://localhost:4000/study/2023-04-25-algorithmStudy-dfsbfs/" rel="alternate" type="text/html" title="[알고리즘] BFS &amp;amp; DFS 알고리즘" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T20:56:11+09:00</updated><id>http://localhost:4000/study/algorithmStudy-dfsbfs</id><content type="html" xml:base="http://localhost:4000/study/2023-04-25-algorithmStudy-dfsbfs/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#bfsbreadth-first-search" id="markdown-toc-bfsbreadth-first-search">BFS(Breadth-first search)</a>    <ul>
      <li><a href="#너비-우선-탐색이란" id="markdown-toc-너비-우선-탐색이란">너비 우선 탐색이란?</a></li>
      <li><a href="#구현-방법" id="markdown-toc-구현-방법">구현 방법</a></li>
      <li><a href="#구현-코드" id="markdown-toc-구현-코드">구현 코드</a></li>
    </ul>
  </li>
  <li><a href="#dfsdepth_first-search" id="markdown-toc-dfsdepth_first-search">DFS(Depth_First Search)</a>    <ul>
      <li><a href="#깊이-우선-탐색이란" id="markdown-toc-깊이-우선-탐색이란">깊이 우선 탐색이란?</a></li>
      <li><a href="#구현-방법-1" id="markdown-toc-구현-방법-1">구현 방법</a></li>
      <li><a href="#구현-코드-1" id="markdown-toc-구현-코드-1">구현 코드</a></li>
    </ul>
  </li>
</ul>
<hr />
<h2 id="bfsbreadth-first-search">BFS(Breadth-first search)</h2>

<h3 id="너비-우선-탐색이란">너비 우선 탐색이란?</h3>
<hr />
<p>시작 정점을 방문한 후 시작 정점에 인접한 모든 정점들을 우선 방문하는 방법이다. 더 이상 방문하지 않은 정점이 없을 때까지 방문하지 않은 모든 정점들에 대해서 BFS 방식을 적용한다.</p>

<p>List로 구현할 경우 큐  방식을 활용해야만 레벨 순서대로 접근이 가능하다.</p>

<ul>
  <li>장점
    <ul>
      <li>출발 노드에서 목표 노드까지 최단 길이 경로를 보장한다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 많은 기억 공간을 필요로 하게 된다.</li>
    </ul>
  </li>
</ul>

<h3 id="구현-방법">구현 방법</h3>
<hr />
<p>BFS의 경우 queue를 이용해 구현하게 된다.</p>

<ol>
  <li>queue와 방문기록을 남겨줄 visited를 함께 만들어준다.</li>
  <li>queue에는 우선 루트 노드만을 저장한다.</li>
  <li>루프문을 돌면서 큐에서 노드를 꺼내 해당 노드와 연결된 노드들을 검사한다.</li>
  <li>만약 연결된 노드가 방문하지 않은 노드라면 결과에 추가해주고 queue에 연결된 노드를 넣어주는 것을 반복한다.</li>
  <li>위 3,4번 과정을 반복하면 너비 우선 탐색을 진행한다.</li>
</ol>

<h3 id="구현-코드">구현 코드</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    from collections import deque
    
    def BFS():
        while queue:
            node = queue.popleft()
            result2.append(node)
            for i in range(N+1):
                if arr[node][i] == 1 and visited2[i] == 0:
                    queue.append(i)
                    visited2[i] = 1
    
    # input
    N, M, V = map(int, input().split())
    
    arr = list([0] * (N+1) for _ in range(N+1))
    visited2 = [0] * (N+1)
    for _ in range(M):
        a, b = map(int, input().split())
        arr[a][b] = 1
        arr[b][a] = 1
    
    result2 = []
    visited2[V] = 1
    queue = deque()
    queue.append(V)
    BFS()

</code></pre></div></div>

<h2 id="dfsdepth_first-search">DFS(Depth_First Search)</h2>

<h3 id="깊이-우선-탐색이란">깊이 우선 탐색이란?</h3>
<hr />
<p>탐색 트리에서 최근에 첨가된 노드를 선택하고, 이 노드에 적용 가능한 다음 노드를 자식 노드로 첨가하며, 첨가된 자식 노드가 목표 노드일 때까지 같은 방식을 반복해 나가는 방식이다.</p>

<p>깊이 제한에 도달한 경우에는 최근에 첨가되었던 부모 노드로 되돌아와서, 다른 적용 가능한 자식 노드를 첨가하며 다시 진행한다.</p>

<p>장점</p>
<ul>
  <li>저장공간의 수요가 적다</li>
  <li>목표 노드가 깊은 단계에 있을 경우 해를 빠르게 구할 수 있다.</li>
</ul>

<p>단점</p>
<ul>
  <li>해가 없는 경로에 들어가도 끝까지 탐색을 하게 된다.</li>
  <li>얻어진 해가 최단 경로가 된다는 보장은 없다. 목표에 이르는 경로가 다수인 문제에 대해서 DFS는 해를 구하면 탐색을 끝내버리므로, 얻은 해가 최적이 아닐 수도 있다.</li>
</ul>

<h3 id="구현-방법-1">구현 방법</h3>
<hr />
<p>재귀를 이용하여 DFS를 하는 방법을 알아보겠다.</p>

<ol>
  <li>방문기록을 저장해 줄 visited를 만들어준다.</li>
  <li>루트 노드부터 탐색을 시작한다.</li>
  <li>현재 노드를 결과에 추가한다.</li>
  <li>현재 노드와 연결된 노드들을 검사한다.</li>
  <li>연결된 노드가 방문하지 않은 노드라면 우선 그 노드로 들어간다.</li>
  <li>계속해서 3,4,5번을 반복하다가 더 이상 탐색할 노드가 없다면 트리를 하나씩 올라온다.</li>
  <li>만약 다시 올라온 노드에 탐색할 노드가 남아있다면 다시 그 노드를 탐색하러 들어가는 것을 반복한다.</li>
</ol>

<h3 id="구현-코드-1">구현 코드</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    def DFS(V):
        result.append(V)
        visited[V] = 1
        for i in range(N+1):
            if arr[V][i] == 1 and visited[i] == 0:
                DFS(i)
    
    # input
    N, M, V = map(int, input().split())
    
    arr = list([0] * (N+1) for _ in range(N+1))
    visited = [0] * (N+1)
    for _ in range(M):
        a, b = map(int, input().split())
        arr[a][b] = 1
        arr[b][a] = 1
    
    result = []
    DFS(V)

</code></pre></div></div>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="study" /><summary type="html"><![CDATA["내용 정리"]]></summary></entry><entry><title type="html">[알고리즘] Binary Search 알고리즘</title><link href="http://localhost:4000/study/2023-04-25-algorithmStudy-binarysearch/" rel="alternate" type="text/html" title="[알고리즘] Binary Search 알고리즘" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T20:36:58+09:00</updated><id>http://localhost:4000/study/algorithmStudy-binarysearch</id><content type="html" xml:base="http://localhost:4000/study/2023-04-25-algorithmStudy-binarysearch/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#이진탐색이란" id="markdown-toc-이진탐색이란">이진탐색이란?</a></li>
  <li><a href="#구현-방법" id="markdown-toc-구현-방법">구현 방법</a></li>
  <li><a href="#구현-코드" id="markdown-toc-구현-코드">구현 코드</a></li>
</ul>
<hr />
<h3 id="이진탐색이란">이진탐색이란?</h3>
<hr />
<p>데이터가 정렬돼 있는 리스트에서 특정한 값을 찾아내기 위한 알고리즘 <br />
검색이 반복될 때마다 완전탐색과는 다르게 검색 범위를 절반으로 줄일 수 있는 장점이 있다.</p>

<h3 id="구현-방법">구현 방법</h3>
<hr />
<p>리스트 내 Left, Mid, right 값을 사용하며 찾고자 하는 값에 따라 Mid 값을 계속해서 계산해준다.</p>

<ol>
  <li>리스트 내 첫 인덱스를 Left(= 0)라 지정하고 가장 마지막을 Right(= len(list)-1)라고 지정한다.</li>
  <li>mid = (left + right) // 2, 계산해서 중간 인덱스값을 구한다.</li>
  <li>찾고싶은 값이 list[mid]보다 작으면 right = mid-1, 크다면 left = mid+1로 업데이트 시켜준다.</li>
  <li>2,3번 과정을 반복하면 찾고자하는 값을 구할 수 있다.</li>
</ol>

<p>이런 특징 때문에 이진탐색은 무조건 정렬되어있는 리스트에서만 사용이 가능하다.</p>

<h3 id="구현-코드">구현 코드</h3>
<hr />
<p>2가지 방법이 존재하며 재귀함수로 구현하는 것과 반복문으로 구현하는 것이 있다.</p>
<ol>
  <li>재귀 함수로 구현한 이진 탐색</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    def binary_search_recursive(list, target, left, right):
        if left &gt; right:
            return
    
        mid = (left + right) // 2
        
        if list[mid] == target:
            return mid
        elif list[mid] &gt; target:
            return binary_search_recursive(list, target, left, mid-1)
        else:
            return binary_search_recursive(list, target, left, mid - 1)

</code></pre></div></div>

<ol>
  <li>반복문으로 구현한 이진탐색</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    def binary_search_iter(list, target, left, right):
        while left &lt;= right:
            mid = (left + right) // 2
            
            if list[mid] == target:
                return mid
            elif list[mid] &gt; target:
                right = mid - 1
            else:
                left = mid + 1
        
        return

</code></pre></div></div>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="study" /><summary type="html"><![CDATA["내용 정리"]]></summary></entry><entry><title type="html">[알고리즘] D.P 알고리즘</title><link href="http://localhost:4000/study/2023-04-25-algorithmStudy-dp/" rel="alternate" type="text/html" title="[알고리즘] D.P 알고리즘" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T20:39:43+09:00</updated><id>http://localhost:4000/study/algorithmStudy-dp</id><content type="html" xml:base="http://localhost:4000/study/2023-04-25-algorithmStudy-dp/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#dpdynamic-programming이란" id="markdown-toc-dpdynamic-programming이란">DP(Dynamic Programming)이란?</a></li>
  <li><a href="#구현-방법" id="markdown-toc-구현-방법">구현 방법</a></li>
  <li><a href="#주의할-점" id="markdown-toc-주의할-점">주의할 점</a></li>
  <li><a href="#dp-활용방식" id="markdown-toc-dp-활용방식">DP 활용방식</a></li>
</ul>
<hr />
<h3 id="dpdynamic-programming이란">DP(Dynamic Programming)이란?</h3>
<hr />
<p>문제를 작은 문제로 (중복될 수도 있지만) 분할하여 분할된 문제의 해답을 기록해 놓은 후 더 큰 문제의 해답을 계산할 때 재사용하는 방법을 의미한다.</p>

<h3 id="구현-방법">구현 방법</h3>
<hr />
<p>DP 알고리즘의 4단계 분류</p>
<ol>
  <li>해답의 구조를 파악해 어떻게 부문제로 나눌 지 결정</li>
  <li>부문제의 해답을 어떻게 조합해 더 큰 문제의 해답을 만들 수 있는지 식을 마련</li>
  <li>작은 문제에서 큰 문제로 적당한 순서에 따라 해답을 계산하여 테이블에 저장하고 재사용하여 답을 계산</li>
  <li>위의 단계들이 원래 문제의 답을 항상 출력함을 증명하고 답을 리턴</li>
</ol>

<h3 id="주의할-점">주의할 점</h3>
<hr />
<ul>
  <li>DP Table을 만들 때 list index error에 대한 고려 항상 해줄 것</li>
</ul>

<h3 id="dp-활용방식">DP 활용방식</h3>
<hr />
<p><strong>Bottom-up 방식</strong></p>
<ul>
  <li>우리말로 ‘상향식’</li>
  <li>가장 작은 문제들부터 답을 찾아 가면서 마지막에는 전체 문제의 답을 구하는 방식</li>
  <li>반복문으로 구현하므로 시간과 메모리의 사용량이 상대적으로 적음</li>
</ul>

<p><strong>Top-down 방식</strong></p>
<ul>
  <li>우리말로 ‘하향식’</li>
  <li>큰 문제를 해결하기 위해 작은 문제를 호출하는 방식</li>
  <li>재귀호출을 통해 구한다. 함수 호출의 횟수를 줄이기 위해 메모이제이션 기법을 활용</li>
</ul>

<blockquote>
  <p>메모이제이션 기법 <br />
-&gt; 컴퓨터 프로그램이 동일한 계산을 반복할 때, 이전에 계산한 값을 메모리에 저장해놓는 방법
DP의 핵심이 되는 기술이다.</p>
</blockquote>

<p><strong>누적 합 활용 방식</strong></p>
<ul>
  <li>배열이 있을 때 해당 배열까지의 총 합을 따로 배열에 저장하는 방식</li>
  <li>시간복잡도 상 큰 이득을 가져다주는 경우가 많다</li>
</ul>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="study" /><summary type="html"><![CDATA["내용 정리"]]></summary></entry><entry><title type="html">[알고리즘] Dijkstra 알고리즘</title><link href="http://localhost:4000/study/2023-04-25-algorithmStudy-dijkstra/" rel="alternate" type="text/html" title="[알고리즘] Dijkstra 알고리즘" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T20:09:38+09:00</updated><id>http://localhost:4000/study/algorithmStudy-dijkstra</id><content type="html" xml:base="http://localhost:4000/study/2023-04-25-algorithmStudy-dijkstra/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#다익스트라-알고리즘이란" id="markdown-toc-다익스트라-알고리즘이란">다익스트라 알고리즘이란?</a></li>
  <li><a href="#구현-방법" id="markdown-toc-구현-방법">구현 방법</a></li>
  <li><a href="#구현-코드" id="markdown-toc-구현-코드">구현 코드</a></li>
  <li><a href="#참조" id="markdown-toc-참조">참조</a></li>
</ul>
<hr />
<h3 id="다익스트라-알고리즘이란">다익스트라 알고리즘이란?</h3>
<hr />
<p>다익스트라 알고리즘은 그래프에서 두 정점 간의 최단 경로를 찾는 알고리즘이다. 간선에 가중치가 주어진 방향 그래프를 대상으로만 사용할 수 있다는 특징이 있다.</p>

<p><img src="/assets/img/study/graph.png" alt="graph" /></p>

<p>이 알고리즘은 최단 경로를 구하는 과정에서 최단 경로 트리가 만들어지는데 최단 경로 트리는 출발점으로 정한 정점에서 각 정점까지의 최단 경로를 저장해 놓은 트리를 뜻한다.</p>

<p>예를 들어, 위 그림에서 a에서 i까지의 최단경로를 구한다면 다익스트라 알고리즘은 a에서 정점 g 혹은 h까지의 최단거리를 구한 후 다시 i까지를 계산한다. <br />
식으로 정리하면, 시작 정점에서 x 정점까지의 최단경로를 dist[x], 간선에 가중치를 x-&gt;y라 표현</p>

<blockquote>
  <p>dist[i] = min(dist[g] + g-&gt;i, dist[h] + h-&gt;i)</p>
</blockquote>

<p>즉, i까지의 최단경로를 구하려면 저 과정을 거쳐 각 정점마다 최단경로를 구하며 찾아간다. 그래서 우리는 i까지 가는 경로 내에 있는 정점들의 최단경로를 구할 수 있는 것이다.</p>

<h3 id="구현-방법">구현 방법</h3>
<hr />
<ul>
  <li>다익스트라 알고리즘은 우선 <strong>가중치가 주어진 방향 그래프</strong>에만 사용이 가능</li>
  <li>우선순위 큐를 이용해 최소가 되는 것부터 지워나가는 것이 중요하다.</li>
  <li>
    <p>만약 정점에 연결된 다른 모든 정점들의 가중치를 비교해나간다면 벨만-포드 알고리즘으로 시간복잡도가 O(N^3)까지 증가한다.</p>
  </li>
  <li>단계별 정리
    <ol>
      <li>출발 정점과 도착 정점을 정한다.</li>
      <li>정점과 정점 사이의 연결관계와 가중치를 저장해준다.</li>
      <li>우선순위 큐를 활용한다.</li>
      <li>우선순위 큐에 현재 정점에 연결된 정점의 정보와 가중치를 넣어준다.</li>
      <li>가중치가 적은 것부터 꺼내서 비교하고 업데이트 시켜준다.</li>
      <li>위 4,5번 과정을 반복한다.</li>
    </ol>
  </li>
</ul>

<h3 id="구현-코드">구현 코드</h3>
<hr />
<p><a href="https://www.acmicpc.net/problem/1753">백준 1753 최단경로 문제</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    import math
    import sys
    import heapq
    
    def dijkstra():
        heap = []
        heapq.heappush(heap, (0, K))
        while heap:
            currentWeight, currentVertex = heapq.heappop(heap)
    
            for nextVertex, weight in graph[currentVertex]:
                nextWeight = currentWeight + weight
                # 이미 해당 정점까지 계산된 경로가 지금 계산하려는 값보다 작다면 이미 최단경로이다
                if shortPath[nextVertex-1] &gt; nextWeight:  
                    shortPath[nextVertex-1] = nextWeight
                    heapq.heappush(heap, (nextWeight, nextVertex))
    
    # input
    input = sys.stdin.readline
    inf = math.inf
    
    V, E = map(int, input().split())
    K = int(input())
    
    graph = [[] for _ in range(V+1)]
    for _ in range(E):
        u, v, w = map(int, input().split())
        graph[u].append([v, w])
    
    # main
    shortPath = [inf for _ in range(V)]
    shortPath[K-1] = 0  # 시작점은 0
    dijkstra()

</code></pre></div></div>

<ul>
  <li>그래프 구현 시 2차원 배열을 생성해 가중치를 저장해주는 방식도 있으나 메모리가 많이 소모된다는 단점이 있다.</li>
</ul>

<h3 id="참조">참조</h3>
<hr />
<p><a href="https://www.youtube.com/watch?v=0NrlN88D9Fs&amp;list=PLsMufJgu5932XYejsOwcUDJ2F75f56nrl&amp;index=49&amp;pp=iAQB">신찬수 교수님 유튜브 강의영상</a> <br />
<a href="https://m.blog.naver.com/ndb796/221234424646">안경잡이개발자 님 네이버 블로그</a></p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="study" /><summary type="html"><![CDATA["내용 정리"]]></summary></entry><entry><title type="html">[알고리즘] Backtracking 알고리즘</title><link href="http://localhost:4000/study/2023-04-25-algorithmStudy-backtracking/" rel="alternate" type="text/html" title="[알고리즘] Backtracking 알고리즘" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T20:15:03+09:00</updated><id>http://localhost:4000/study/algorithmStudy-backtracking</id><content type="html" xml:base="http://localhost:4000/study/2023-04-25-algorithmStudy-backtracking/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#백트래킹이란" id="markdown-toc-백트래킹이란">백트래킹이란?</a></li>
  <li><a href="#구현-방법" id="markdown-toc-구현-방법">구현 방법</a></li>
</ul>
<hr />
<h3 id="백트래킹이란">백트래킹이란?</h3>
<hr />
<ul>
  <li>해를 찾는 도중 해가 아니어서 막히면, 되돌아가서 다시 해를 찾아가는 기법을 말한다.</li>
  <li>주로 최적화 문제와 결정 문제를 푸는 방법이 된다.</li>
</ul>

<h3 id="구현-방법">구현 방법</h3>
<hr />
<ul>
  <li>해를 찾아가는 도중, 지금의 경로가 해가 될 것 같지 않으면 그 경로를 더 이상 가지 않고 되돌아간다.</li>
</ul>

<ol>
  <li>어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없다고 판단 하면 유망성이 없다, 그렇지 않다면 유망성이 있다고 한다.</li>
  <li>어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드 탐색을 시작한다. 이 과정을 <strong>가지치기</strong>라 한다.</li>
  <li>반대로 어떤 노드의 점검 결과가 유망하다고 결정되면 탐색을 계속한다.</li>
  <li>위 2,3 과정을 반복하면서 탐색을 계속한다.</li>
</ol>

<blockquote>
  <p>가지치기(pruning) <br />
-&gt; 유망하지 않는 노드가 포함된 경로는 더 이상 탐색X</p>
</blockquote>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="study" /><summary type="html"><![CDATA["내용 정리"]]></summary></entry><entry><title type="html">블록체인</title><link href="http://localhost:4000/it/2023-04-24-it-blockchain/" rel="alternate" type="text/html" title="블록체인" /><published>2023-04-24T00:00:00+09:00</published><updated>2023-04-25T19:28:24+09:00</updated><id>http://localhost:4000/it/it-blockchain</id><content type="html" xml:base="http://localhost:4000/it/2023-04-24-it-blockchain/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#정의" id="markdown-toc-정의">정의</a></li>
  <li><a href="#기술의-특징" id="markdown-toc-기술의-특징">기술의 특징</a></li>
  <li><a href="#핵심-구성-요소" id="markdown-toc-핵심-구성-요소">핵심 구성 요소</a></li>
  <li><a href="#블록체인-연결되는-방식" id="markdown-toc-블록체인-연결되는-방식">블록체인 연결되는 방식</a></li>
  <li><a href="#블록체인-네트워크-유형" id="markdown-toc-블록체인-네트워크-유형">블록체인 네트워크 유형</a></li>
  <li><a href="#참조" id="markdown-toc-참조">참조</a></li>
</ul>
<hr />
<h3 id="정의">정의</h3>
<hr />
<ul>
  <li>
    <p>블록체인은 블록들을 체인으로 연결해놓은 것</p>
  </li>
  <li><strong>블록</strong>이라고 하는 소규모 데이터들이 관리 대상 데이터를 P2P 방식을 기반으로 생성된 체인 형태의 연결고리 기반 분산 데이터 저장 환경에 저장하는 방식</li>
  <li>합의 없이 체인을 삭제하거나 수정할 수 없으므로 데이터가 시간 순서대로 일관성이 있음</li>
  <li>결과적으로 주문, 결제, 계정, 기타 트랜잭션을 추적하기 위해 변경 불가능한 분산 원장을 생성할 수 있음</li>
</ul>

<blockquote>
  <p>분산 원장이란? <br />
분산 원장은 탈중앙화의 특징을 가진 트랜잭션 데이터베이스를 뜻한다. 여기서 원장은 거래 장부를 뜻하는데 거래에 참여하는 각 당사자는
동일한 거래 장부 사본을 소유하며, 변경 내용은 모두 함께 업데이트 된다.</p>
</blockquote>

<h3 id="기술의-특징">기술의 특징</h3>
<hr />

<p><strong>탈중앙화</strong></p>

<ul>
  <li>중앙 집중식 엔티티에서 분산 네트워크로 이전</li>
  <li>투명성을 사용해 서로 간에 신뢰 필요성이 줄어듬</li>
</ul>

<p><strong>불변성</strong></p>

<ul>
  <li>공유 원장에 거래를 기록하면 참여자는 거래를 조작할 수 없다.</li>
  <li>오류가 발생했을 때는 이전 거래를 지우고 수정하는게 아니라 새로운 거래를 추가해야한다. <br />
(→ 네트워크 내 기록에는 두 개의 거래가 모두 남게된다)</li>
</ul>

<p><strong>합의</strong></p>

<ul>
  <li>거래 기록을 위한 참여자 동의에 관한 규칙을 설정</li>
  <li>과반수가 동의한 경우에만 새로운 거래를 기록 가능</li>
</ul>

<h3 id="핵심-구성-요소">핵심 구성 요소</h3>
<hr />

<p><strong>분산 원장</strong></p>

<ul>
  <li>블록체인 네트워크의 공유 데이터베이스</li>
</ul>

<p><strong>스마트 계약</strong></p>

<ul>
  <li>서드 파티를 지원할 필요 없이 비즈니스 계약을 자체 관리</li>
  <li>미리 정해진 조건이 충족되면 자동으로 실행되는 블록체인 시스템 내 프로그램</li>
</ul>

<p><strong>퍼블릭 키 암호화</strong></p>

<ul>
  <li>블록체인 네트워크 참여자를 고유하게 식별하는 보안 기능, 두 세트로 주어짐</li>
  <li>퍼블릭 키: 모든 사람에게 공통적으로 주어지는 키</li>
  <li>프라이빗 키: 구성원 고유의 키</li>
  <li>두 개의 키가 함께 작동하여 원장의 데이터 잠금을 해제하는 방식</li>
</ul>

<h3 id="블록체인-연결되는-방식">블록체인 연결되는 방식</h3>
<hr />

<p><img src="/assets/img/it/block.png" alt="blockchain" /></p>

<ul>
  <li>블록은 계속해서 만들어져 나온다.</li>
  <li>블록에 데이터를 저장해서 <em>블록체인</em>에 연결을 시키기 위해서는 일련의 과정이 필요하다.</li>
</ul>

<ol>
  <li>블록체인 내 연결할 블록의 해시값을 가져온다.</li>
  <li>저장하고 싶은 데이터를 해싱을 통해 해시값을 생성해낸다.</li>
  <li>두 개의 해시값에 채굴자가 Nonce 값을 찾아내 새로운 해시값을 생성해낸다.</li>
</ol>

<blockquote>
  <p>Nonce란? <br />
새로운 해시값은 제약조건이 존재하기 때문에 적절한 Nonce 값을 찾아줘야한다. <br />
적절한 Nonce 값을 찾기 위해서 계속해서 변경되기 때문에 ‘임시값’이라고도 한다.</p>
</blockquote>

<ul>
  <li>위 과정을 거쳐 블록들이 연결되기 때문에 이미 블록에 저장되어있는 데이터를 변경하려하면 데이터의 해시값이 변하게 된다.(불변성)</li>
</ul>

<h3 id="블록체인-네트워크-유형">블록체인 네트워크 유형</h3>
<hr />

<p><strong>퍼블릭 블록체인</strong></p>

<ul>
  <li>모든 사람이 블록체인에 참여할 수 있다.</li>
  <li>모든 구성원은 Read &amp; Write 과 Validation을 할 권리를 갖는다</li>
  <li>암호화폐의 대부분은 퍼블릭 블록체인을 사용한다(ex. Bitcoin, Ethereum)</li>
</ul>

<p><strong>프라이빗 블록체인</strong></p>

<ul>
  <li>단일 조직의 관리형 블록체인이라고도 불린다.</li>
  <li>해당 조직에서 구성원과 권한을 결정할 수 있다.</li>
  <li>따라서, 접근 제한을 위해 부분적으로만 분산시켜 놓는 특징이 있다</li>
</ul>

<p><strong>하이브리드 블록체인</strong></p>

<ul>
  <li>프라이빗 &amp; 퍼블릭 네트워크 결합</li>
  <li>기존 퍼블릭 시스템에 권한 기반 프라이빗 시스템을 설정하는 것</li>
  <li>블록체인 내 특정 데이터에 대한 액세스는 제어하면서 나머지 데이터는 공개</li>
  <li>
    <p>예를 들어, 퍼블릭 회원이 프라이빗 거래가 완료되었는지를 확인할 수는 있지만 프라이빗 거래 내역에 접근해 거래 내용을 확인하는 행위 등을 제한할 수 있게 하는 방법이 있다.</p>
  </li>
  <li>장점
    <ul>
      <li>폐쇄형 생태계에서 작동하므로 정보 유출에 대한 위험이 없다</li>
      <li>목적에 따라 규칙을 바꿀 수 있다</li>
      <li>일정한 노드만 참여가 가능하기 때문에 트랜잭션 비용이 저렴하다.</li>
    </ul>
  </li>
</ul>

<h3 id="참조">참조</h3>
<hr />
<p><a href="https://aws.amazon.com/ko/what-is/blockchain/?aws-products-all.sort-by=item.additionalFields.productNameLowercase&amp;aws-products-all.sort-order=asc">AWS 블록체인 관련 문서</a> <br />
<a href="https://www.sap.com/korea/insights/what-is-blockchain.html">SAP 블록체인 관련 문서</a> <br />
<a href="https://www.youtube.com/watch?v=TljQRfHRId8&amp;list=PL7jH19IHhOLOJfXeVqjtiawzNQLxOgTdq">노마드 코더 영상</a></p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="it" /><summary type="html"><![CDATA["블록체인 기술 관련"]]></summary></entry><entry><title type="html">[Jekyll] GitHub 블로그 개발일지(2)</title><link href="http://localhost:4000/jekyll/2023-04-21-jekyll-theme/" rel="alternate" type="text/html" title="[Jekyll] GitHub 블로그 개발일지(2)" /><published>2023-04-21T00:00:00+09:00</published><updated>2023-04-26T21:23:38+09:00</updated><id>http://localhost:4000/jekyll/jekyll-theme</id><content type="html" xml:base="http://localhost:4000/jekyll/2023-04-21-jekyll-theme/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#21-새로운-테마-선정" id="markdown-toc-21-새로운-테마-선정">2.1 새로운 테마 선정</a></li>
  <li><a href="#22-새로운-테마-적용" id="markdown-toc-22-새로운-테마-적용">2.2 새로운 테마 적용</a></li>
  <li><a href="#23-주의할-점" id="markdown-toc-23-주의할-점">2.3 주의할 점</a></li>
</ul>

<hr />
<h3 id="21-새로운-테마-선정">2.1 새로운 테마 선정</h3>
<hr />
<ul>
  <li><a href="https://velog.io/@juxgsiroo/github-page-pt2">juxgsiroo 님 Velog</a> 추천 참조</li>
</ul>

<blockquote>
  <p>기존에 쓰던 테마가 너무 단순하고 밋밋하다는 생각이 들던 때에 새로운 테마를 구경하게 되었고 지금까지 했던걸
과감히 버리고서라도 변경하기로 결정했다</p>
</blockquote>

<h3 id="22-새로운-테마-적용">2.2 새로운 테마 적용</h3>
<ul>
  <li>기존에 저장했던 Markdown 폴더들을 전부 따로 빼준 뒤 레포지토리를 비워주었다</li>
  <li>이전에 했던 것 처럼 Hydejack을 Zip으로 가져와 레포지토리에 넣어주는 방식을 활용</li>
  <li><a href="https://github.com/hydecorp/hydejack">hydecorp/hydejack Repository</a></li>
  <li>
    <p>당연히 해당 repository를 가져오면 될 것이라 생각했지만 이 파일에는 gemfile이 존재하지 않는다</p>

    <p><img src="/assets/img/jekyll/noGem.png" alt="Nogem" /></p>
  </li>
</ul>

<blockquote>
  <p>gemfile이 없다면 ‘bundle exec jekyll serve’ 를 실행 시
‘Could not locate Gemfile’ 이라는 Error가 발생한다.</p>
</blockquote>

<ul>
  <li>해결방법은 간단하다</li>
  <li><a href="https://github.com/hydecorp/hydejack-starter-kit">hydecorp/hydejack-starter-kit</a></li>
  <li>해당 레포지토리로 이동하면 스타터킷 답게 다 포함되어있는 것을 확인할 수 있다.</li>
  <li>(추가) masterkit으로 다운받았지만 현재 버전과 다른 점이 많아 버전에 맞춰 다운받는것이 편할 수도 있다.</li>
</ul>

<h3 id="23-주의할-점">2.3 주의할 점</h3>
<hr />
<ul>
  <li>minimal mistakes 테마를 사용하던 때와는 다르게 조심해줘야할 점들이 많았다.</li>
  <li>많이 안 쓰는 테마여서 웬만해서는 Guide나 Demo site와 코드를 비교해보며 알아가야했다.</li>
</ul>

<p><strong>2.3.1</strong> _config.yml Theme 설정</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
    # Theme
    # ---------------------------------------------------------------------------------------
    
    #theme: jekyll-theme-hydejack
    remote_theme: hydecorp/hydejack@v9

</code></pre></div></div>

<ul>
  <li>해당 코드를 보면 theme와 remote_theme가 나누어져있다</li>
  <li>local에서 테스트 해볼 때는 theme를 주석처리를 풀고 remote_theme를 주석처리</li>
  <li>서버에 올릴 떄는 위의 예시코드처럼 사용해주어야함</li>
</ul>

<blockquote>
  <p>따로 layout 폴더를 만들지 않고 Jekyll에서 기본으로 주어지는 layout plugin을 사용하기 때문에
상황에 맞게 바꿔주지 않으면 해당 부분이 로드되지 않는다.</p>
</blockquote>

<p><strong>2.3.2</strong> 폴더 경로 설정</p>
<ul>
  <li>가장 시간을 많이 잡아먹었고 스트레스 받았던 부분이다.
    <ul>
      <li>아래와 같이 Local에서는 제대로 동작해도 서버에 올리면 다르게 동작하는 등 많은 문제점이 발생했다.</li>
    </ul>

    <p><img src="/assets/img/jekyll/pathError.png" alt="Error" /></p>
  </li>
  <li>우선 _featured_categories 폴더에 카테고리 별로 분류를 해주기 위한 Markdown 파일을 작성</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
    ---
    # Featured tags need to have either the `list` or `grid` layout (PRO only).
    layout: list
    
    # The title of the tag's page.
    title: Algorithm
    
    # The name of the tag, used in a post's front matter (e.g. tags: [&lt;slug&gt;]).
    slug: algorithm
    
    # (Optional) Write a short (~150 characters) description of this featured tag.
    description: &gt;
        알고리즘 문제 풀이
    
    # (Optional) You can disable grouping posts by date.
    # no_groups: true
    
    sitemap: false
    ---

</code></pre></div></div>

<ul>
  <li>
    <p>다음으로 카테고리에 post를 올리기 위해서는 해당 사진처럼 해준다</p>

    <p><img src="/assets/img/jekyll/path.png" width="450px" height="100px" /></p>
  </li>
  <li>
    <p>주의해야할 점은 _config 파일에 해당 포맷대로 파일명을 작성해줘야 인식한다는 점이다.</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    # Format of the permalinks
    permalink:             /:categories/:year-:month-:day-:title/

</code></pre></div></div>

<blockquote>
  <p>이외에도 필자는 Blog라는 키워드는 CHANGELOG.md 파일의 특정 부분과 문제를 일으켜서 사용 시 버그가 발생하는 문제점이 있었다.
누군가는 이글을 보며 조금이라도 편하게 Hydejack 테마를 이용할 수 있기를 바라는 마음에 작성한다.</p>
</blockquote>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="jekyll" /><summary type="html"><![CDATA["빠르게 찾아온 더 이쁜 테마에 대한 열망"]]></summary></entry></feed>