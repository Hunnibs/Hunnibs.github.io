<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-05-23T01:03:20+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hunnibs</title><subtitle>About my work history &amp; review
</subtitle><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><entry><title type="html">[Java] 변수</title><link href="http://localhost:4000/categories/java/2023-05-23-java-variable/" rel="alternate" type="text/html" title="[Java] 변수" /><published>2023-05-23T00:00:00+09:00</published><updated>2023-05-23T00:39:36+09:00</updated><id>http://localhost:4000/categories/java/java-variable</id><content type="html" xml:base="http://localhost:4000/categories/java/2023-05-23-java-variable/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#기본-데이터-타입" id="markdown-toc-기본-데이터-타입">기본 데이터 타입</a></li>
</ul>
<hr />
<h3 id="기본-데이터-타입">기본 데이터 타입</h3>
<hr />

<p><img src="assets\img\java\DataTypes.png" alt="DataType" /></p>

<p>데이터 타입은 크게 논리형, 문자형, 정수형, 실수형으로 나누어진다.</p>

<p><strong>논리형</strong></p>
<ul>
  <li>true, false와 같은 참, 거짓을 판별하는 Data를 저장하는 변수</li>
  <li>1byte의 크기를 가진다.</li>
</ul>

<p><strong>문자형</strong></p>
<ul>
  <li>딱 하나의 문자만을 저장할 수 있는 변수, 하나 이상의 문자를 저장할 시 오류가 발생한다.</li>
  <li>2byte의 크기를 가진다.</li>
</ul>

<p><strong>정수형</strong></p>
<ul>
  <li>
    <p>Data 크기와 저장할 수 있는 값의 범위에 따라 다양하게 나뉜다.</p>

    <ul>
      <li>byte는 1byte로 가장 작은 크기이며 -128 ~ 127까지만을 저장할 수 있다.</li>
      <li>short와 char는 2byte의 크기를 가지며 short는 음수와 양수를 반반 씩, char는 양수범위만 저장한다.</li>
      <li>int는 4byte로 더 넓은 범위를 저장할 수 있다.</li>
      <li>long은 8byte로 웬만하면 모든 범위의 수를 저장할 수 있다.
        <ul>
          <li>단, 변수 선언시 long big = 234141515<em>L</em>로 L을 붙여줘야한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>실수형</strong></p>
<ul>
  <li>
    <p>소수점 아래 자리까지 저장할 수 있는 type으로 크기는 두 가지로 나뉜다.</p>

    <ul>
      <li>float은 4byte</li>
      <li>double 8byte</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>👉 상수</p>

  <p>기본 데이터 타입 앞에 final을 붙여서 불변성을 가진 data 저장공간을 만들 수 있다. <br />
ex) final int number = 3; 이면, number는 3이라는 값으로 고정된다.</p>
</blockquote>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="categories" /><category term="java" /><summary type="html"><![CDATA["변수"]]></summary></entry><entry><title type="html">[SWEA] 1928_Base64 Decoder</title><link href="http://localhost:4000/categories/algorithm/2023-05-19-algorithm-SWEA_1928/" rel="alternate" type="text/html" title="[SWEA] 1928_Base64 Decoder" /><published>2023-05-19T00:00:00+09:00</published><updated>2023-05-19T14:58:50+09:00</updated><id>http://localhost:4000/categories/algorithm/algorithm-SWEA_1928</id><content type="html" xml:base="http://localhost:4000/categories/algorithm/2023-05-19-algorithm-SWEA_1928/"><![CDATA[<blockquote>
  <p><a href="https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PR4DKAG0DFAUq">https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5PR4DKAG0DFAUq</a></p>
</blockquote>

<h3 id="문제-해결-과정">문제 해결 과정</h3>
<hr />
<p><strong>문제 해석</strong></p>
<ul>
  <li>이 부분은 문제에 대한 이해가 가지 않아 <em>최준아_0847231님</em>의 댓글을 참고했다.</li>
</ul>

<blockquote>
  <p>문제요약</p>
  <ol>
    <li>표1을 보고 입력받은 문자들을 각각 대응하는 숫자로 변경한다.</li>
    <li>각 숫자들을 6자리 이진수로 표현하고, 이 이진수들을 한 줄로 쭉 이어 붙인다.</li>
    <li>한 줄로 쭉 이어붙인 이진수들을 8자리씩 끊어서 십진수로 바꾼다.</li>
    <li>각각의 십진수를 아스키 코드로 변환한다.</li>
  </ol>
</blockquote>

<p><strong>접근 방식</strong></p>
<ul>
  <li>
    <p>문제가 어렵다기보다는 아스키 코드를 활용할 수 없다면 풀 수가 없는 문제였다.</p>

    <p><a href="https://hunnibs.github.io/categories/study/2023-05-03-algorithmStudy-ascii/">[기본 지식] Ascii Code</a> 해당 포스트 내용 참조</p>
  </li>
</ul>

<h3 id="풀이-코드">풀이 코드</h3>
<hr />

<p><strong>코드 구성 설명</strong></p>
<ol>
  <li>주어진 문자열에서 문자 하나하나 당 아스키코드 변환식을 통해 자연수로 바꿔준다.</li>
  <li>바꿔준 자연수를 decoding(num) 함수에 넣어 이진수로 변환해준다.</li>
  <li>전부 이진수로 변환했다면 translate(sum) 함수에 넣어 8자리씩 슬라이스를 이용해 끊어준 뒤, 다시 정수로 변환시켜준다.</li>
  <li>정수로 변환시켜주고 아스키코드 변환을 이용해 다시 문자열로 변환해준다.</li>
  <li>3~4 과정을 끝까지 반복하면 완전한 문장이 완성된다.</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    def decoding(num):
        decode = ''
        for i in range(5, -1, -1):
            if num - (2**i) &gt;= 0:
                decode += '1'
                num = num - (2**i)
            else:
                decode += '0'

        return decode

    def translate(sum):
        result = ''

        a = len(sum) // 8
        for i in range(a):
            b = i * 8
            tmp = sum[b:b+8]

            num = 0
            i = 7
            for t in tmp:
                t = int(t)
                num += t * (2**i)
                i -= 1

            result += chr(num)
        return result

    # input
    T = int(input())
    for t in range(1, T+1):
        base = input()
        sum = ''

    # main
        for word in base:
            if 48 &lt;= ord(word) &lt;= 57:
                num = ord(word)+4
                sum += decoding(num)

            elif 65 &lt;= ord(word) &lt;= 90:
                num = ord(word)-65
                sum += decoding(num)

            elif 97 &lt;= ord(word) &lt;= 122:
                num = ord(word)-71
                sum += decoding(num)

            elif word == '+':
                num = 62
                sum += decoding(num)

            else:
                num = 63
                sum += decoding(num)
        
        result = translate(sum)
        
        print('#' + str(t), result)

</code></pre></div></div>

<h3 id="문제풀이-후기">문제풀이 후기</h3>
<hr />
<p>오랜만에 풀어보는 재밌는 문제였던 것 같다. 알고리즘을 푼다는 생각보다는 암호해석을 하는 듯 하여 재밌었다. 문제 자체의 난이도는 높지 않은 것 같으나 본인도 아스키코드 표를 참조하지 않고는 풀기가 힘들었던 문제였다. 그만큼 아스키 코드에 대해 다 외우고 있지 못한다면 풀기 어려운 문제라고 생각한다.</p>

<p>총 소요시간: 0H 30M</p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="categories" /><category term="algorithm" /><summary type="html"><![CDATA["구현 문제(Ascii code표 활용)"]]></summary></entry><entry><title type="html">[SWEA] 1244_최대상금</title><link href="http://localhost:4000/categories/algorithm/2023-05-17-algorithm-SWEA_1244/" rel="alternate" type="text/html" title="[SWEA] 1244_최대상금" /><published>2023-05-17T00:00:00+09:00</published><updated>2023-05-18T11:18:43+09:00</updated><id>http://localhost:4000/categories/algorithm/algorithm-SWEA_1244</id><content type="html" xml:base="http://localhost:4000/categories/algorithm/2023-05-17-algorithm-SWEA_1244/"><![CDATA[<blockquote>
  <p><a href="https://swexpertacademy.com/main/code/problem/problemDetail.do?problemLevel=2&amp;problemLevel=3&amp;contestProbId=AV15Khn6AN0CFAYD&amp;categoryId=AV15Khn6AN0CFAYD&amp;categoryType=CODE&amp;problemTitle=&amp;orderBy=RECOMMEND_COUNT&amp;selectCodeLang=ALL&amp;select-1=3&amp;pageSize=10&amp;pageIndex=1">https://swexpertacademy.com/main/code/problem/problemDetail.do?problemLevel=2&amp;problemLevel=3&amp;contestProbId=AV15Khn6AN0CFAYD&amp;categoryId=AV15Khn6AN0CFAYD&amp;categoryType=CODE&amp;problemTitle=&amp;orderBy=RECOMMEND_COUNT&amp;selectCodeLang=ALL&amp;select-1=3&amp;pageSize=10&amp;pageIndex=1</a></p>
</blockquote>

<h3 id="문제-해결-과정">문제 해결 과정</h3>
<hr />
<p><strong>문제 해석</strong></p>
<ul>
  <li>정해진 횟수만큼 두 숫자의 위치를 바꿨을 때(중복 가능), 가장 큰 숫자가 나와야한다.</li>
</ul>

<p><strong>접근 방식</strong></p>
<ul>
  <li>
    <p>Greedy 알고리즘 활용(잘못된 접근)</p>

    <p>매 번 최선의 선택을 하면 결과값이 최선일거라는 실수를 저질렀다. greedy 방식의 경우는 최적의 선택들을 계속 한다해서 결과가 최적이라는 보장이 없다는 것을 공부할 때 정리하고도 문제를 풀 때 생각없이 사용했다.</p>

    <p><a href="https://hunnibs.github.io/categories/study/2023-04-20-algorithmStudy-Greedy/">[알고리즘] Greedy 알고리즘</a> 해당 포스트 내용 참조</p>
  </li>
</ul>

<blockquote>
  <p>조건을 다시 생각</p>
  <ol>
    <li>max값을 가장 맨 앞에 오게 하는 것이 최대가 되게 하는 방식</li>
    <li>max값이 여러개라면? 일일히 탐색해보며 결과가 가장 최대가 될 때를 고르자</li>
  </ol>

  <p>해당 문제는 최대 6자리 교환횟수 10번 이내이므로 DFS 알고리즘과 브루트포스 알고리즘을 함께 사용해 모든 경우를 다 탐색해봐도 가능할 것이라고 생각했다.</p>
</blockquote>

<ul>
  <li>
    <p>Queue를 활용한 DFS 알고리즘 활용(잘못된 접근)</p>

    <p>max 값을 가장 앞으로 이동시켰을 때 popleft를 통해 제거해준다면 시간복잡도가 더 단순해질 것으로 생각했다. 하지만 여러가지 조건들을 추가하다보니 재귀문에서 돌아올 때 제거했던 값을 다시 넣어주는 것이 너무 복잡했고 계속해서 index error가 발생해서 포기했다.</p>
  </li>
  <li>
    <p>DFS 알고리즘 활용(실제 풀이)</p>

    <p>시간이 오래걸리더라도 가장 깔끔하게 답을 구할 수 있는 방식으로 조건이 까다로운 부분만 해결하면 문제없이 구현할 수 있었다.</p>
  </li>
</ul>

<h3 id="풀이-코드">풀이 코드</h3>
<hr />

<ul>
  <li>코드가 매우 난잡해 최대한 주석을 달아 설명하려함</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    # cnt는 남은 반복 횟수, 0 ~ C는 이미 정렬된 숫자를 의미한다. 즉, C는 이제 가장 큰 숫자가 와야하는 index값
    def sol(cnt, C):
        # 해당 조건문은 깊이가 최대에 달했을 때를 처리
        if cnt == 0:
            tmp = []
            for i in range(len(answer)):
                tmp.append(str(answer[i]))
            for i in range(C, len(nums)):
                tmp.append(str(nums[i]))

            result.append(''.join(tmp))

            return

        # 해당 루프문은 만약 가장 큰 숫자가 가장 앞에 있는 경우는 변경할 필요가 없어 처리해줌
        while max(nums) == nums[C]:
            answer.append(nums[C])
            nums[C] = -1
            C += 1

            if C == len(nums):
                break

        # cnt는 남았는데 이미 최대금액으로 정렬된 경우
        if C == len(nums):
            if cnt % 2 == 0 or status:  
            # 중복되는 숫자가 있다면 그 숫자들만 자리를 바꿔주거나 
            # or 중복되지않아도 남은 횟수가 짝수면 다시 원래대로 돌려놓을 수 있다.
                tmp = []
                for i in range(len(answer)):
                    tmp.append(str(answer[i]))
                result.append(''.join(tmp))
            # 자리를 바꿔줘야하는 경우
            else:
                tmp = answer[-1]
                answer[-1] = answer[-2]
                answer[-2] = tmp
                tmp = []
                for i in range(len(answer)):
                    tmp.append(str(answer[i]))
                result.append(''.join(tmp))

            return

        maxNum = max(nums)

        # DFS 동작 코드
        for i in range(len(nums)):
            if nums[i] == maxNum:
                nums[i] = nums[C]
                nums[C] = -1
                answer.append(maxNum)
                sol(cnt-1, C+1)
                answer.pop()
                nums[C] = nums[i]
                nums[i] = maxNum

    # input
    T = int(input())
    for t in range(1, T+1):
        result = []
        answer = []

        nums, cnt = input().split(' ')

    # main
        cnt = int(cnt)
        nums = list(nums)
        for i in range(len(nums)):
            nums[i] = int(nums[i])

        status = 0
        # 중복 Status
        if len(set(nums)) != len(nums):
            status = 1

        sol(cnt, 0)

        ans = 0
        while not ans:
            if len(max(result)) != len(nums):
                result[result.index(max(result))] = ''
            else:
                ans = max(result)

        print('#' + str(t), ans)

</code></pre></div></div>

<h3 id="문제풀이-후기">문제풀이 후기</h3>
<hr />
<p>체감 상 굉장히 까다로운 문제였다. 조건이 많고 시간과 공간복잡도를 생각했을 때 섣불리 코드를 짜기가 어려워 줄이려고 노력하다가 시간이 오래걸렸던 것 같다. 느꼈던 건 뭔가 구현문제에 가까웠던 것 같다.</p>

<p>총 소요시간: 3H</p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="categories" /><category term="algorithm" /><summary type="html"><![CDATA["구현 문제"]]></summary></entry><entry><title type="html">[SWEA] 1859_백만 장자 프로젝트</title><link href="http://localhost:4000/categories/algorithm/2023-05-15-algorithm-SWEA_1859/" rel="alternate" type="text/html" title="[SWEA] 1859_백만 장자 프로젝트" /><published>2023-05-15T00:00:00+09:00</published><updated>2023-05-18T11:18:18+09:00</updated><id>http://localhost:4000/categories/algorithm/algorithm-SWEA_1859</id><content type="html" xml:base="http://localhost:4000/categories/algorithm/2023-05-15-algorithm-SWEA_1859/"><![CDATA[<blockquote>
  <p><a href="https://swexpertacademy.com/main/code/problem/problemDetail.do?problemLevel=2&amp;contestProbId=AV5LrsUaDxcDFAXc&amp;categoryId=AV5LrsUaDxcDFAXc&amp;categoryType=CODE&amp;problemTitle=&amp;orderBy=RECOMMEND_COUNT&amp;selectCodeLang=ALL&amp;select-1=2&amp;pageSize=10&amp;pageIndex=1">https://swexpertacademy.com/main/code/problem/problemDetail.do?problemLevel=2&amp;contestProbId=AV5LrsUaDxcDFAXc&amp;categoryId=AV5LrsUaDxcDFAXc&amp;categoryType=CODE&amp;problemTitle=&amp;orderBy=RECOMMEND_COUNT&amp;selectCodeLang=ALL&amp;select-1=2&amp;pageSize=10&amp;pageIndex=1</a></p>
</blockquote>

<h3 id="문제-해결-과정">문제 해결 과정</h3>
<hr />
<p><strong>문제 해석</strong></p>
<ul>
  <li>N일 동안의 매매가가 각각 주어졌을 때 저점에 매수해 고점에 파는 것을 반복해 최대 이익을 구하는 것</li>
</ul>

<p><strong>접근 방식</strong></p>
<ol>
  <li>
    <p>이중 for문을 이용한 간단한 구현 방식(Time Error)</p>

    <p>1일차부터 N-1일차까지 뒤 전부를 돌며 가장 고점에 판매하는 방식으로 구현만 가능할 뿐 시간복잡도가 O(n^2)으로 복잡한 편이다.</p>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    import sys

    # input
    input = sys.stdin.readline

    T = int(input())

    for t in range(1, T+1):
        N = int(input())
        value = list(map(int, input().split()))
        result = 0
        for i in range(N-1):
            tmp = 0
            for j in range(i+1, N):
                if value[i] &lt; value[j]:
                    tmp = max(tmp, value[j]-value[i])
            result += tmp

        print('#' + str(t), result)

</code></pre></div></div>

<ol>
  <li>
    <p>max값을 이용한 구현 방식</p>

    <ul>
      <li>매매가 정보가 리스트로 주어졌을 때 가장 고점인 날을 구한다.</li>
      <li>가장 고점인 날을 high라고 했을 때, 1일차부터 high-1일차까지는 전부 매수하고 high에서 전부 매도한다.</li>
      <li>큐의 특성을 이용해 1일차부터 순서대로 나아가면서 리스트에서 없애준다.</li>
      <li>계속해서 하락장인 경우 O(N^2)까지 증가할 수 있으나 O(N)에 보통 해결 가능하다.</li>
    </ul>
  </li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    import sys
    from collections import deque

    # input
    input = sys.stdin.readline

    T = int(input())

    for t in range(1, T+1):
        N = int(input())
        value = list(map(int, input().split()))

        value = deque(value)
        answer = 0
        while value:
            high = max(value)
            idx = value.index(high)
            for _ in range(idx):
                answer += (high - value.popleft())
            value.popleft()

        print('#' + str(t), answer)

</code></pre></div></div>

<h3 id="문제-풀이-후기">문제 풀이 후기</h3>
<hr />
<p>시간복잡도 생각 안하고 풀지말고 따져보면서 효율적인 코드 작성하려고 노력하자</p>

<p>총 소요시간: 0H 30M</p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="categories" /><category term="algorithm" /><summary type="html"><![CDATA["구현 문제(큐 활용)"]]></summary></entry><entry><title type="html">[BOJ] 1238_파티</title><link href="http://localhost:4000/categories/algorithm/2023-05-09-algorithm-BOJ_1238/" rel="alternate" type="text/html" title="[BOJ] 1238_파티" /><published>2023-05-09T00:00:00+09:00</published><updated>2023-05-18T11:17:45+09:00</updated><id>http://localhost:4000/categories/algorithm/algorithm-BOJ_1238</id><content type="html" xml:base="http://localhost:4000/categories/algorithm/2023-05-09-algorithm-BOJ_1238/"><![CDATA[<blockquote>
  <p><a href="https://www.acmicpc.net/problem/1238">https://www.acmicpc.net/problem/1238</a></p>
</blockquote>

<h3 id="문제-해결-과정">문제 해결 과정</h3>
<hr />
<p><strong>문제 해석</strong></p>
<ul>
  <li>각 노드를 출발해 정해진 노드에 방문하고 다시 출발 노드로 되돌아오는 최단경로를 구하는 문제</li>
</ul>

<p><strong>접근 방식</strong></p>
<ul>
  <li>최단경로 문제 풀이 방식은 정해져있음</li>
  <li>최단경로를 구할 때 그래프에 <strong>가중치</strong>가 정해져있다면 BFS가 아닌 Dijkstra 알고리즘을 활용 <br />
<a href="https://hunnibs.github.io/categories/study/2023-04-25-algorithmStudy-dijkstra/">[알고리즘] 다익스트라 알고리즘</a> 해당 포스트 내용 참조</li>
  <li>해당 구분만 하면 다익스트라 알고리즘만 구현하면 문제 풀이는 끝</li>
</ul>

<p>단, 해당 문제는 목표노드에 도달하면 끝나는 것이 아니라 다시 출발 노드로 돌아와야하므로 조건을 추가해야한다.</p>
<ul>
  <li>목표 노드 X를 출발점으로 잡고 해당 노드에서 다른 노드까지의 최단경로를 저장해준 리스트를 만들어준다.</li>
  <li>목표 노드를 제외한 나머지 노드들부터 목표 노드까지 최단경로를 찾아준다.</li>
  <li>기존에 구했던 목표노드부터 출발노드까지의 최단경로와 방금 구한 목표노드까지의 최단경로를 더해서 각 노드 별로 저장해준다.</li>
  <li>각 노드 당 목표노드를 들렀다 복귀하는 최단경로가 저장된 리스트를 얻을 수 있다.</li>
  <li>이 중 최대값이 해당 문제에서 요구하는 정답이다.</li>
</ul>

<h3 id="풀이-코드">풀이 코드</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    import heapq
    import sys
    from math import inf

    def dijkstra(i, shortPath):
        heap = []
        heapq.heappush(heap, (0, i))
        while heap:
            currentW, currentV = heapq.heappop(heap)

            for nextV, w in graph[currentV]:
                nextW = currentW + w
                if shortPath[nextV] &gt; nextW:
                    shortPath[nextV] = nextW
                    heapq.heappush(heap, (nextW, nextV))

        return shortPath

    # input
    input = sys.stdin.readline

    N, M, X = map(int, input().split())

    graph = [[] for _ in range(N+1)]
    for _ in range(M):
        u, v, w = map(int, input().split())
        graph[u].append([v, w])

    # main
    result = [0 for _ in range(N+1)]

    shortPathX = [inf for _ in range(N+1)]
    shortPathX[X] = 0
    shortPathX = dijkstra(X, shortPathX)

    for i in range(1, N+1):
        if i == X:
            continue

        shortPath = [inf for _ in range(N+1)]
        shortPath[i] = 0
        shortPath = dijkstra(i, shortPath)
        result[i] = shortPath[X] + shortPathX[i]

    print(max(result))

</code></pre></div></div>

<ul>
  <li>자세한 다익스트라 구현 방식은 남겨둔 포스트를 참조할 것</li>
</ul>

<h3 id="문제-풀이-후기">문제 풀이 후기</h3>
<hr />
<p>아직은 Dijkstra 알고리즘 사용이 익숙하지 않고 Heap을 자유롭게 사용하지 못해 포스트 내용을 참조해서 문제를 풀어야했다. 그래도 문제를 보고 어떤 알고리즘을 써야할지 빠르게 파악했다는 점에 공부가 되고있다는 생각이 들었던 문제였던 것 같다.</p>

<p>총 소요시간: 0H 45M</p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="categories" /><category term="algorithm" /><summary type="html"><![CDATA["다익스트라 활용 문제"]]></summary></entry><entry><title type="html">[알고리즘] Floyd-Warshall 알고리즘</title><link href="http://localhost:4000/categories/study/2023-05-09-algorithmStudy-Floyd/" rel="alternate" type="text/html" title="[알고리즘] Floyd-Warshall 알고리즘" /><published>2023-05-09T00:00:00+09:00</published><updated>2023-05-10T16:02:28+09:00</updated><id>http://localhost:4000/categories/study/algorithmStudy-Floyd</id><content type="html" xml:base="http://localhost:4000/categories/study/2023-05-09-algorithmStudy-Floyd/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#플로이드-워셜-알고리즘이란" id="markdown-toc-플로이드-워셜-알고리즘이란">플로이드-워셜 알고리즘이란?</a></li>
  <li><a href="#구현-방법" id="markdown-toc-구현-방법">구현 방법</a></li>
  <li><a href="#구현-코드" id="markdown-toc-구현-코드">구현 코드</a></li>
  <li><a href="#참조" id="markdown-toc-참조">참조</a></li>
</ul>
<hr />
<h3 id="플로이드-워셜-알고리즘이란">플로이드-워셜 알고리즘이란?</h3>
<hr />
<p>플로이드-워셜 알고리즘(Floyd-Warshall Algorithm)은 변의 가중치가 음이거나 양인 (음수 사이클은 없는) 가중 그래프에서 최단 경로들을 찾는 알고리즘이다. All-to-all shortest path라고도 표현하며 해당 알고리즘은 DP 알고리즘을 활용해야한다. <br />
목적은 모든 노드 간의 최단 경로의 길이를 찾는 것이다.</p>

<p><strong>Wikipedia 예시</strong> <br />
<img src="\assets\img\study\Floyd_Wiki.png" alt="graph" /></p>

<p>아래는 dist 리스트의 변화를 K 값에 따라 보여준다.(K값은 반드시 지나야하는 경로를 뜻함) <br />
<img src="\assets\img\study\Floyd_WikiG.png" alt="table" /></p>

<h3 id="구현-방법">구현 방법</h3>
<hr />
<ul>
  <li>플로이드-워셜 알고리즘도 다익스트라 알고리즘과 같이 <strong>가중치가 주어진 방향 그래프</strong>에만 사용이 가능</li>
  <li>
    <p>시간 복잡도는 복잡하지만 모든 정점들 사이의 최단경로를 구하는 점과 음수 가중치에 대해서도(음수 사이클은 존재하지 않아야한다.) 처리할 수가 있다.</p>
  </li>
  <li>단계별 정리
    <ol>
      <li>경유하는 노드가 없을 때 최단거리를 저장해준다.(이 때, 서로 연결된 간선이 없는 노드 간은 inf로 저장한다)</li>
      <li>경유하는 노드를 1부터 n번 노드까지 정해준다.</li>
      <li>각 노드 별로 경유하는 노드를 지나 다른 노드로 갈 때의 거리와 원래 다른 노드로 갈 때의 거리를 비교한다.</li>
      <li>만약, 경유해서 가는 거리가 더 짧다면 최단거리를 업데이트 한다.</li>
    </ol>
  </li>
</ul>

<h3 id="구현-코드">구현 코드</h3>
<hr />
<p><a href="https://www.acmicpc.net/problem/11404">백준 11404 플로이드 문제</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    import sys
    from math import inf

    # input
    input = sys.stdin.readline

    n = int(input())
    m = int(input())

    graph = [[inf for _ in range(n)] for _ in range(n)]
    for _ in range(m):
        a, b, c = map(int, input().split())
        graph[a-1][b-1] = min(graph[a-1][b-1], c)

    # main
    for K in range(n):
        for i in range(n):
            for j in range(n):
                graph[i][j] = min(graph[i][j], graph[i][K] + graph[K][j])

    for i in range(n):
        graph[i][i] = 0

    for i in range(n):
        for j in range(n):
            if graph[i][j] == inf:
                print(0, end=' ')
            else:
                print(graph[i][j], end=' ')
        print()

</code></pre></div></div>

<ul>
  <li>실제 Floyd-Warshall 코드는 # main 아래 5줄이 전부이다.</li>
  <li>해당 문제에서는 시작도시와 도착도시가 같은 경우는 없어야하므로 0으로 초기화해줬다.</li>
</ul>

<h3 id="참조">참조</h3>
<hr />
<p><a href="https://www.youtube.com/watch?v=bKa7bfXQi3A&amp;list=PLsMufJgu5932XYejsOwcUDJ2F75f56nrl&amp;index=52&amp;t=1163s">신찬수 교수님 유튜브 강의영상</a> <br />
<a href="https://ko.wikipedia.org/wiki/%ED%94%8C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%9B%8C%EC%85%9C_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">Wikipedia 플로이드-워셜 알고리즘</a></p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="categories" /><category term="study" /><summary type="html"><![CDATA["내용 정리"]]></summary></entry><entry><title type="html">AI</title><link href="http://localhost:4000/categories/it/2023-05-05-it-AI/" rel="alternate" type="text/html" title="AI" /><published>2023-05-05T00:00:00+09:00</published><updated>2023-05-09T13:41:10+09:00</updated><id>http://localhost:4000/categories/it/it-AI</id><content type="html" xml:base="http://localhost:4000/categories/it/2023-05-05-it-AI/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#정의" id="markdown-toc-정의">정의</a></li>
  <li><a href="#인공지능-종류" id="markdown-toc-인공지능-종류">인공지능 종류</a></li>
  <li><a href="#ai-장단점" id="markdown-toc-ai-장단점">AI 장단점</a></li>
  <li><a href="#ai-적용-사례" id="markdown-toc-ai-적용-사례">AI 적용 사례</a></li>
  <li><a href="#참조" id="markdown-toc-참조">참조</a></li>
</ul>
<hr />
<h3 id="정의">정의</h3>
<hr />
<ul>
  <li>AI는 학습, 문제 해결, 빅데이터 등과 같이 인간 지능과 연결된 인지 문제를 해결하는데 주력하는 분야이다.</li>
  <li>컴퓨터 공학 분야뿐만 아니라 데이터 분석 및 통계, 하드웨어 및 소프트웨어 엔지니어링, 언어학, 신경과학은 물론 철학과 심리학도 포함되는 광범위한 분야이다.</li>
  <li>우리가 주로 아는 AI는 머신러닝과 딥러닝을 기반으로 하는 기술모음으로 데이터 분석, 예상 및 예측, 객체 분류, 자연어 처리, 추천, 등을 수행한다.</li>
</ul>

<p>인공지능 기능</p>
<ol>
  <li>학습(Learning): <br />
과거의 패턴들로부터 학습할 수 있는 능력을 가지고 있다.</li>
  <li>문제 해결(Problem Solving): <br />
복잡한 문제를 분석하고 해결할 수 있는 능력을 가지고 있다.</li>
  <li>빅데이터(Big Data): <br />
아주 큰 용량의 변화하는 데이터를 처리할 수 있다.</li>
  <li>추론(Reasoning): <br />
주위의 상황으로부터 추록할 수 있는 능력을 가지고 있다.</li>
</ol>

<ul>
  <li>아래는 인공지능 기술 활용방안에 따라 나눠지는 관계도이다.</li>
</ul>

<p align="center"><img src="/assets/img/it/AI.png" width="300px" height="300px" title="px(픽셀) 크기 설정" alt="AI" /></p>

<ul>
  <li>인공지능: <br />
사람의 지적 능력을 컴퓨터를 통해 구현하는 기술</li>
  <li>머신러닝: <br />
사람이 정한 모델과 특징 추출 방법을 이용하여 데이터를 기반으로 학습해서 추론할 수 있게 하는 기술</li>
  <li>딥러닝: <br />
인공신경망 방법을 이용해 만든 머신러닝 기술로, 빅데이터 학습에 적합한 기술</li>
</ul>

<h3 id="인공지능-종류">인공지능 종류</h3>
<hr />
<ol>
  <li>ANI(Artificial Narrow Intelligence)
    <ul>
      <li>흔히 ‘약인공지능’이라고 부른다.</li>
      <li>매우 복잡한 알고리즘과 신경망에 의해 구동될 수도 있지만 매우 목표지향적</li>
      <li>기능이 부족하기 보다는 정의 상 진정한 지능으로 인정하는 인적요소를 갖추지 않아 Narrow intelligence라 칭함</li>
      <li>ex) 얼굴 인식, 인터넷 검색, 자율주행차</li>
    </ul>
  </li>
  <li>AGI(Artificial General Intelligence)
    <ul>
      <li>흔히 ‘강인공지능’이라고 부른다.</li>
      <li>인간이 할 수 있는 지능적인 작업을 성공적으로 수행할 수 있어야한다.</li>
      <li>ANI와 같이 경험으로부터 학습하고 패턴을 발견 및 예측이 가능하다.</li>
      <li>ANI와 다른 점은 AGI는 기존 알고리즘에서 다루지 않은 것도 추정할 수 있다는 점이다.</li>
    </ul>
  </li>
  <li>ASI(Artificial Super Intelligence)
    <ul>
      <li>흔히 ‘초인공지능’이라고 부른다.</li>
      <li>이론적으로는 완전히 자기를 인식하는 AI</li>
      <li>인간의 행동을 흉내내거나 이해하는 정도를 벗어나 근본적으로 파악이 가능하다.</li>
      <li>아직은 개념만 있을 뿐 먼 미래의 이야기이다.</li>
    </ul>
  </li>
</ol>

<h3 id="ai-장단점">AI 장단점</h3>
<hr />
<p><strong>장점</strong></p>
<ul>
  <li>
    <p>자동화 <br />
사람들과 별개로 AI는 독립적이고 자율적으로 지속적인 작업이 가능하다.</p>
  </li>
  <li>
    <p>사람의 실수 감소 <br />
AI는 매번 동일한 프로세스를 따르는 자동화 및 알고리즘을 통해 작업을 하기 때문에 실수가 발생할 일이 드물다.</p>
  </li>
  <li>
    <p>반복적인 작업 제거 <br />
반복적인 작업을 수행하는 일에 알고리즘만 작성한다면 자동으로 수행해 그 일을 하던 인적 자원을 다른 곳에 투자 가능하다.</p>
  </li>
  <li>
    <p>빠르고 정확함 <br />
AI는 인간보다 더 빠르고 정확하게 일을 처리할 수 있으며 사람과 달리 휴식의 필요성이 없다. 이는 모든 작업에 가속도를 붙여줄 수 있다.</p>
  </li>
</ul>

<p><strong>단점</strong></p>
<ul>
  <li>
    <p>윤리적 문제점 <br />
딥 페이크(Deepfake)와 가짜뉴스 같이 AI와 머신러닝을 사용한 외설적인 동영상을 만들거나 믿을만한 가짜뉴스를 생성하는 등 AI의 발전으로 생길 수 있는 문제점이 만들어진다.</p>
  </li>
  <li>
    <p>AI 편향 <br />
인공지능 시스템에 나타나는 특정 편향 문제를 해결할 수 있어야한다.</p>

    <p>예를 들어, 아마존에서 개발하던 인공지능 채용 시스템에서 여성 차별적 인식이 드러나 폐기됐었다. 이유는 채용시스템에 쓰인 데이터에 10년간 아마존 지원자 데이터를 통한 분석 결과 남성 지원자가 압도적으로 많아 시스템 자체가 여성 지원자를 선호하지 않는 쪽으로 학습된 것이다.</p>
  </li>
</ul>

<h3 id="ai-적용-사례">AI 적용 사례</h3>
<hr />
<ul>
  <li>
    <p>의료 부문 <br />
데이터를 활용한 진단과 치료를 진행하는 방식</p>
  </li>
  <li>
    <p>금융 부문 <br />
가장 빠르게 도입한 분야 중 하나로 AI봇, 디지털 결제 어드바이저, 생체인식 부정행위 감지 메커니즘 등 효율성과 고객 서비스를 개선하기 위해 활용</p>
  </li>
  <li>
    <p>제조 부문 <br />
중앙 시스템을 통해 데이터를 주고 받기 위해 기기를 연결하면 IoT 네트워크를 구성한다. 해당 정보를 이용해 최상의 워크플로를 유지한다.</p>
  </li>
  <li>
    <p>농업 부문 <br />
수확량을 높이고 지속가능하도록 활용.  <br />
재배 및 수확 단계에서 유통망과 수요까지 분석해 농부가 수확하기에 가장 효율적인 시기를 알려준다.</p>
  </li>
</ul>

<h3 id="참조">참조</h3>
<hr />
<p><a href="https://www.sap.com/korea/products/artificial-intelligence/what-is-artificial-intelligence.html">SAP</a> <br />
<a href="https://cloud.google.com/learn/what-is-artificial-intelligence?hl=ko#section-3">Google Cloud</a> <br />
<a href="https://tta.or.kr/data/androReport/ttaJnal/20220614094203135_cumq.pdf">인공지능 편향성 이슈와 신뢰성 확보방안</a></p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="categories" /><category term="it" /><summary type="html"><![CDATA["Artificial Intelligence(AI) 기술 관련"]]></summary></entry><entry><title type="html">[기본 지식] Ascii Code</title><link href="http://localhost:4000/categories/study/2023-05-03-algorithmStudy-ascii/" rel="alternate" type="text/html" title="[기본 지식] Ascii Code" /><published>2023-05-03T00:00:00+09:00</published><updated>2023-05-19T14:31:46+09:00</updated><id>http://localhost:4000/categories/study/algorithmStudy-ascii</id><content type="html" xml:base="http://localhost:4000/categories/study/2023-05-03-algorithmStudy-ascii/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#아스키-코드란" id="markdown-toc-아스키-코드란">아스키 코드란?</a></li>
  <li><a href="#활용-예시" id="markdown-toc-활용-예시">활용 예시</a></li>
</ul>
<hr />
<h3 id="아스키-코드란">아스키 코드란?</h3>
<hr />
<p><img src="/assets/img/study/ascii.gif" alt="ascii" /></p>

<p>컴퓨터에서 기호 혹은 문자를 기억하고 있는 체계로 알아두면 좋은 것들이다. <br />
대표적으로,</p>
<ul>
  <li>48 ~ 57: 실제 숫자 0~9를 담당</li>
  <li>65 ~ 90: A ~ Z</li>
  <li>97 ~ 122: a ~ z</li>
</ul>

<p>해당 구간은 반드시 외우는 것이 편하다.</p>

<h3 id="활용-예시">활용 예시</h3>
<hr />
<blockquote>
  <p><a href="https://school.programmers.co.kr/learn/courses/30/lessons/72410">https://school.programmers.co.kr/learn/courses/30/lessons/72410</a></p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    def solution(new_id):
        answer = ''
        
        for word in new_id:
            if len(answer) == 15:
                break
            
            if 65 &lt;= ord(word) &lt;= 90:
                word = chr(ord(word)+ 32)
                answer += word
            elif 97 &lt;= ord(word) &lt;= 122:
                answer += word
            elif 48 &lt;= ord(word) &lt;= 57:
                answer += word
            elif word == '-' or word == '_':
                answer += word
            elif word == '.':
                if not answer or answer[-1] == '.':
                    continue
                else:
                    answer += word
        
        for i in range(len(answer)-1, -1, -1):
            if answer[i] == '.':
                answer = answer[:i]
                print(answer)
            else:
                break
        
        while len(answer) &lt;= 2:
            if not answer:
                answer += 'a'
            else:
                answer += answer[-1]
        
        return answer

</code></pre></div></div>

<p>해당 문제를 Ascii 코드표를 활용해 풀어본 코드이다.</p>

<p>대소문자 변환은 파이썬에서 ascii 코드표를 활용하지않고 간단하게 해결할 수 있는 방법이 존재한다.</p>
<ul>
  <li>String.upper() &amp; String.lower()</li>
  <li>위를 사용하면 문자열 전체를 대소문자로 자동으로 변환해준다.</li>
</ul>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="categories" /><category term="study" /><summary type="html"><![CDATA["내용 정리"]]></summary></entry><entry><title type="html">핀테크</title><link href="http://localhost:4000/categories/it/2023-05-02-it-fintech/" rel="alternate" type="text/html" title="핀테크" /><published>2023-05-02T00:00:00+09:00</published><updated>2023-05-02T15:32:43+09:00</updated><id>http://localhost:4000/categories/it/it-fintech</id><content type="html" xml:base="http://localhost:4000/categories/it/2023-05-02-it-fintech/"><![CDATA[<ul id="markdown-toc">
  <li><a href="#정의" id="markdown-toc-정의">정의</a></li>
  <li><a href="#핀테크-예시" id="markdown-toc-핀테크-예시">핀테크 예시</a></li>
  <li><a href="#핀테크-사용-이유" id="markdown-toc-핀테크-사용-이유">핀테크 사용 이유</a></li>
  <li><a href="#참조" id="markdown-toc-참조">참조</a></li>
</ul>
<hr />
<h3 id="정의">정의</h3>
<hr />
<p>핀테크(Fintech)란 금융(<strong>Fin</strong>ance)에 IT 기술(<strong>Tech</strong>nology)을 접목하여 금융 관련 서비스를 효율적으로 제공하는 것을 뜻한다. <br />
기존의 금융회사에서 모든 서비스를 제공하는 방식이 우리가 알고있는 인터넷 뱅킹이라면 핀테크는 금융 서비스를 쪼개어서 하나의 분야를 전문적으로 서비스하는 방법이다.</p>

<blockquote>
  <p>-&gt; 인터넷 뱅킹(internet banking): <br />
전자 금융의 일종으로 인터넷 회선을 이용하여 은행과 사용자 간의 금융 업무를 처리하는 시스템이다.
온라인 뱅킹, 홈 뱅킹은 유의어다.</p>
</blockquote>

<h3 id="핀테크-예시">핀테크 예시</h3>
<hr />
<p><strong>간편송금/지급결제</strong></p>
<ul>
  <li>모바일 기기를 이용한 간편결제 방식</li>
  <li>기존의 공인인증서를 이용한 복잡한 인증 절차 없이 주로 자체 보안 방식(이체 비밀번호, 지문인식, 홍채인식, 얼굴인식 등)인 바이오인증을 활용한다.</li>
  <li>ex) 토스, 카카오페이, 네이버페이, 페이코, 삼성페이</li>
</ul>

<p><strong>로보어드바이저</strong></p>
<ul>
  <li>컴퓨터 알고리즘을 이용한 자산운용 관련 자동화 서비스</li>
  <li>자신이 원하는 수익률, 위험도 등을 정하면 자동으로 내 자산을 운용해 투자하거나 상품을 추천해준다.(일임형과 자문형으로 나뉜다) <br />
but,</li>
  <li>낮은 수수료와 편리한 접근성에도 불구하고 수익률이 낮은 편</li>
  <li>ex) 불리오, 에임, 하이로보</li>
</ul>

<p><strong>금융상품 추천 서비스</strong></p>
<ul>
  <li>소비자들의 자산관리를 디지털화하여 제공하는 방식</li>
  <li>로보어드바이저와 비슷해 보이지만 자산을 운용해 투자하는 로보어드바이저와 달리 자산을 관리하는데 중점</li>
  <li>카드나 예적금, 대출, 보험 등 다양한 금융상품에 대해 나에게 맞는 상품을 찾을 수 있도록 도와준다.</li>
  <li>ex) NERDWALLET, CREDIT KARMA, 뱅크샐러드</li>
</ul>

<p><strong>크라우드 펀딩</strong></p>
<ul>
  <li>자금이 필요한 개인, 단체, 기업이 웹이나 모바일 네트워크를 활용해 불특정 다수로부터 자금을 모으는 것</li>
  <li>유형이 4가지로 나뉘어진다.
    <ul>
      <li>
        <p>금융대출형:  <br />
대출자의 다양한 데이터를 통해 신용등급을 평가하고 돈이 필요한 사람과 투자자를 매칭해 대출과 투자를 이어주는 방식
ex) 테라펀딩, 렌딧, 8퍼센트</p>
      </li>
      <li>
        <p>투자형: <br />
신생기업이나 개발프로젝트에 투자하고 지분획득하는 방식
ex) 와디즈</p>
      </li>
      <li>
        <p>후원형: <br />
금전적 보상과는 무관한 방식</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="핀테크-사용-이유">핀테크 사용 이유</h3>
<hr />
<p><strong>국내 추진 배경</strong></p>
<ul>
  <li>기존 금융회사 혁신 속도가 느린 문제점</li>
  <li>핀테크는 모바일 결제시장이 열리면서 세계적으로 빠르게 성장하는 중</li>
</ul>

<p><strong>기대효과</strong></p>
<ol>
  <li>
    <p>금융부문 경쟁촉진 <br />
금융권이 공정하게 경쟁하면서 금융시장의 효율성은 높아진다.</p>
  </li>
  <li>
    <p>일자리 창출 <br />
IT와 금융이 융합된 산업인만큼 양질의 일자리 창출 파급력이 크다.</p>
  </li>
  <li>
    <p>소비자 편익 향상 <br />
모바일 결제를 비롯한 다양한 금융서비스를 활용한 편리한 생활이 가능해졌다.</p>
  </li>
</ol>

<h3 id="참조">참조</h3>
<hr />
<p><a href="https://www.korea.kr/special/policyCurationView.do?newsId=148865913">대한민국 정책브리핑: 핀테크</a> <br />
<a href="https://www.banksalad.com/contents/%ED%95%80%ED%85%8C%ED%81%AC-%EA%B0%9C%EB%85%90-%EC%99%84%EB%B2%BD-%EC%A0%95%EB%A6%AC-9752">뱅크샐러드 핀테크 완벽 정리</a> <br />
<a href="https://happyedu.moe.go.kr/happy/bbs/selectHappyArticle.do?bbsId=BBSMSTR_000000005080&amp;nttId=9947">행복한 교육</a></p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="categories" /><category term="it" /><summary type="html"><![CDATA["핀테크 기술 관련"]]></summary></entry><entry><title type="html">[BOJ] 2206 벽 부수고 이동하기</title><link href="http://localhost:4000/categories/algorithm/2023-05-01-algorithm-BOJ_2206/" rel="alternate" type="text/html" title="[BOJ] 2206 벽 부수고 이동하기" /><published>2023-05-01T00:00:00+09:00</published><updated>2023-05-18T11:17:53+09:00</updated><id>http://localhost:4000/categories/algorithm/algorithm-BOJ_2206</id><content type="html" xml:base="http://localhost:4000/categories/algorithm/2023-05-01-algorithm-BOJ_2206/"><![CDATA[<blockquote>
  <p><a href="https://www.acmicpc.net/problem/2206">https://www.acmicpc.net/problem/2206</a></p>
</blockquote>

<h3 id="문제-해결-과정">문제 해결 과정</h3>
<hr />
<p><strong>문제 해석</strong></p>
<ul>
  <li>벽은 단 하나만 필요에 의해 부술 수 있음</li>
  <li>위 조건만 만족하면 그저 최단경로 문제</li>
</ul>

<p><strong>접근 방식</strong></p>
<ul>
  <li>BFS 혹은 DFS 사용한 풀이를 생각</li>
  <li>벽을 부술 수 있는지 여부에 따라 탐색을 달리해야하므로 DFS를 처음에는 선택</li>
  <li>
    <p>BOJ 시스템에서는 재귀를 이용한 DFS 풀이 시 시간초과와 메모리초과가 발생했다</p>
  </li>
  <li>해당 코드는 아래와 같음</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
    import sys
    sys.setrecursionlimit(10**9)
    
    def DFS(x, y, dist, hammer):
        global result
    
        if result &lt; dist:
            return
    
        if x == N-1 and y == M-1:
            if dist &lt; result:
                result = dist
        else:
            for i in range(4):
                tx = x+dx[i]
                ty = y+dy[i]
                if 0 &lt;= tx &lt; N and 0 &lt;= ty &lt; M:
                    if map[tx][ty] == 0 and not visited[tx][ty]:
                        visited[tx][ty] = 1
                        DFS(tx, ty, dist+1, hammer)
                        visited[tx][ty] = 0
                    elif map[tx][ty] == 1 and hammer:
                        visited[tx][ty] = 1
                        hammer = 0
                        DFS(tx, ty, dist+1, hammer)
                        visited[tx][ty] = 0
                        hammer = 1
    
    # input
    input = sys.stdin.readline
    
    N, M = map(int, input().split())
    map = [(list(map(int, list(input().strip())))) for _ in range(N)]
    
    # main
    visited = [[0 for _ in range(M)] for _ in range(N)]
    dx = [0, 0, -1, 1]
    dy = [1, -1, 0, 0]
    
    result = N * M
    DFS(0, 0, 1, 1)
    
    if result == N * M:
        print(-1)
    else:
        print(result)

</code></pre></div></div>

<ul>
  <li>문제점이 뭔지 찾아보던 중 최단경로 문제는 <strong>반드시 BFS</strong>를 사용해야한다는 글을 읽었다. <br />
<a href="https://hunnibs.github.io/categories/study/2023-04-25-algorithmStudy-dfsbfs/">[알고리즘] BFS &amp; DFS 알고리즘</a> 해당 포스트 내용 참조</li>
  <li>그래서 BFS를 이용하고 벽을 부수술 있는가에 대한 유무를 판단하는 Status값을 큐에 함께 넣어주는 방식을 사용했다.</li>
</ul>

<p><strong>문제점</strong></p>
<ul>
  <li>완벽하게 풀었다고 생각했으나 시작점과 출발점이 같은 경우는 출력을 할 때 길이 없다고 판단했다.</li>
  <li>따로 조건을 추가해서 해결했으나 조금 찝찝한 풀이로 완료한 느낌이다.</li>
</ul>

<h3 id="전체-코드">전체 코드</h3>
<hr />

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    
    import sys
    from collections import deque
    
    def BFS():
        while queue:
            x, y, hammer = queue.popleft()  # hammer는 벽을 부술수있는지 여부를 확인하는 Status값
    
            for i in range(4):
                tx = x + dx[i]
                ty = y + dy[i]
                if 0 &lt;= tx &lt; N and 0 &lt;= ty &lt; M:
                    # 벽을 부술 수 있는 경우
                    if hammer:
                        # 벽을 부술 필요가 없는 경우
                        if map[tx][ty] == 0:
                            if not dist[tx][ty]:  # 한 번도 방문하지 않은 경우 업데이트
                                dist[tx][ty] = dist[x][y] + 1
                                queue.append([tx, ty, 1])
                            else:  # 이미 정해진 최단경로보다 값이 작을 때만 탐색을 더 진행한다.
                                if dist[tx][ty] &gt; dist[x][y] + 1:
                                    dist[tx][ty] = dist[x][y] + 1
                                    queue.append([tx, ty, 1])
                        벽을 부숴야하는 경우
                        else:
                            dist_noHam[tx][ty] = dist[x][y] + 1
                            queue.append([tx, ty, 0])
                    # 벽을 부술 수 없는 경우
                    else:
                        if map[tx][ty] == 0:
                            if not dist_noHam[tx][ty]:  # 한 번도 방문하지 않은 경우 업데이트
                                dist_noHam[tx][ty] = dist_noHam[x][y] + 1
                                queue.append([tx, ty, 0])
                            else:  # 이미 정해진 최단경로보다 값이 작을 때만 탐색을 더 진행한다.
                                if dist_noHam[tx][ty] &gt; dist_noHam[x][y] + 1:
                                    dist_noHam[tx][ty] = dist_noHam[x][y] + 1
                                    queue.append([tx, ty, 0])
    
    # input
    input = sys.stdin.readline
    
    N, M = map(int, input().split())
    map = [(list(map(int, list(input().strip())))) for _ in range(N)]
    
    # main
    dist = [[0 for _ in range(M)] for _ in range(N)]
    dist_noHam = [[0 for _ in range(M)] for _ in range(N)]
    # 방향 정보
    dx = [0, 0, -1, 1]
    dy = [1, -1, 0, 0]
    
    queue = deque()
    queue.append([0, 0, 1])
    BFS()
    
    ham = dist[N-1][M-1]
    noHam = dist_noHam[N-1][M-1]
    
    if ham and noHam:
        if ham &gt; noHam:
            print(noHam+1)
        else:
            print(ham+1)
    elif ham:
        print(ham+1)
    elif noHam:
        print(noHam+1)
    elif N == 1 and M == 1:
        print(1)
    else:
        print(-1)

</code></pre></div></div>

<h3 id="문제-풀이-후기">문제 풀이 후기</h3>
<hr />
<p>처음에 DFS로 풀자고 마음을 먹은 것부터 DFS와 BFS를 제대로 이해하지 못했던 것 같다. <br />
최적해를 구하긴하지만 확실한 최단경로를 구하기 위해서는 BFS를 사용해야한다는 것을 알 수 있었던 문제였다.</p>

<p>총 소요 시간: 2H 30M</p>]]></content><author><name>&lt;Lee&gt; &lt;ByungHeon&gt;</name><email>&lt;cqqudgjs@hufs.ac.kr&gt;</email></author><category term="categories" /><category term="algorithm" /><summary type="html"><![CDATA["BFS 활용 문제"]]></summary></entry></feed>